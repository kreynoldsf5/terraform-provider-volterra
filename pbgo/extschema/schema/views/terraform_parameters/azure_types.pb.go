// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/terraform_parameters/azure_types.proto

package terraform_parameters

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	certified_hardware "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/certified_hardware"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Azure Terraform Instance Parameters
//
// x-displayName: "Azure Terraform Instance Parameters"
// Shape of the view terraform parameters specification
type AzureInstanceType struct {
	// Volterra Node Id
	//
	// x-displayName: "Volterra Node ID"
	// Volterra Node ID will be used to refer to this node in other TF parameters
	VoltNodeId string `protobuf:"bytes,1,opt,name=volt_node_id,json=voltNodeId,proto3" json:"volt_node_id,omitempty"`
	// Volterra Vnet id
	//
	// x-displayName: "Volterra Vnet id"
	// Vnet in which Cloud Instance is launched
	VoltVnetId string `protobuf:"bytes,3,opt,name=volt_vnet_id,json=voltVnetId,proto3" json:"volt_vnet_id,omitempty"`
	// Public Subnet
	//
	// x-displayName: "Public Subnet"
	// Public subnet will be used as site local network
	PublicSubnetId string `protobuf:"bytes,4,opt,name=public_subnet_id,json=publicSubnetId,proto3" json:"public_subnet_id,omitempty"`
	// Private Subnet
	//
	// x-displayName: "Private Subnet"
	// Private subnet will be used as site inside network, when node type has two interfaces.
	PrivateSubnetId string `protobuf:"bytes,5,opt,name=private_subnet_id,json=privateSubnetId,proto3" json:"private_subnet_id,omitempty"`
	// Cloud Instance Type
	//
	// x-displayName: "Cloud Instance Type"
	// Cloud instance type like small, medium, large etc
	MachineType string `protobuf:"bytes,6,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// Disk size to be used for this instance
	DiskSize string `protobuf:"bytes,7,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// Azure Image Parameters
	//
	// x-displayName: " Azure Image Parameters"
	// Azure Image parameters
	Marketplace *certified_hardware.Marketplace `protobuf:"bytes,9,opt,name=marketplace,proto3" json:"marketplace,omitempty"`
	// Cloud Instance AZ
	//
	// x-displayName: "Cloud Instance Az"
	// Cloud Instance AZ in which to create this instance
	Az string `protobuf:"bytes,10,opt,name=az,proto3" json:"az,omitempty"`
	// Volterra Node count
	//
	// x-displayName: "Volterra Node count"
	// Desired number of node count used for worker node scaling
	NodeCount int32 `protobuf:"varint,11,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
}

func (m *AzureInstanceType) Reset()      { *m = AzureInstanceType{} }
func (*AzureInstanceType) ProtoMessage() {}
func (*AzureInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{0}
}
func (m *AzureInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureInstanceType.Merge(m, src)
}
func (m *AzureInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *AzureInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureInstanceType proto.InternalMessageInfo

func (m *AzureInstanceType) GetVoltNodeId() string {
	if m != nil {
		return m.VoltNodeId
	}
	return ""
}

func (m *AzureInstanceType) GetVoltVnetId() string {
	if m != nil {
		return m.VoltVnetId
	}
	return ""
}

func (m *AzureInstanceType) GetPublicSubnetId() string {
	if m != nil {
		return m.PublicSubnetId
	}
	return ""
}

func (m *AzureInstanceType) GetPrivateSubnetId() string {
	if m != nil {
		return m.PrivateSubnetId
	}
	return ""
}

func (m *AzureInstanceType) GetMachineType() string {
	if m != nil {
		return m.MachineType
	}
	return ""
}

func (m *AzureInstanceType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

func (m *AzureInstanceType) GetMarketplace() *certified_hardware.Marketplace {
	if m != nil {
		return m.Marketplace
	}
	return nil
}

func (m *AzureInstanceType) GetAz() string {
	if m != nil {
		return m.Az
	}
	return ""
}

func (m *AzureInstanceType) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

// Azure Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating new AWS subnet
type AzureSubnetParamType struct {
	// Azure Resource Group
	//
	// x-displayName: "Resource Group"
	// Resource Group for this subnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,2,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	// IPv6 Subnet
	//
	// x-displayName: "IPv6 Subnet"
	// x-example: "1234:568:abcd:9100::/64"
	// IPv6 subnet prefix for this subnet
	Ipv6 string `protobuf:"bytes,3,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *AzureSubnetParamType) Reset()      { *m = AzureSubnetParamType{} }
func (*AzureSubnetParamType) ProtoMessage() {}
func (*AzureSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{1}
}
func (m *AzureSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetParamType.Merge(m, src)
}
func (m *AzureSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetParamType proto.InternalMessageInfo

func (m *AzureSubnetParamType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *AzureSubnetParamType) GetIpv6() string {
	if m != nil {
		return m.Ipv6
	}
	return ""
}

// Azure Existing Subnet Type
//
// x-displayName: "Azure Existing Subnet Parameters"
// Parameters for existing subnet
type AzureExistingSubnetParamType struct {
	// Existing Subnet Name
	//
	// x-displayName: "Subnet Name"
	// Name of existing subnet.
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// subnet_resource_grp
	//
	// x-displayName: "Resource Group Name"
	// Specify name of Resource Group
	SubnetResourceGrp string `protobuf:"bytes,2,opt,name=subnet_resource_grp,json=subnetResourceGrp,proto3" json:"subnet_resource_grp,omitempty"`
}

func (m *AzureExistingSubnetParamType) Reset()      { *m = AzureExistingSubnetParamType{} }
func (*AzureExistingSubnetParamType) ProtoMessage() {}
func (*AzureExistingSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{2}
}
func (m *AzureExistingSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureExistingSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureExistingSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureExistingSubnetParamType.Merge(m, src)
}
func (m *AzureExistingSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *AzureExistingSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureExistingSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureExistingSubnetParamType proto.InternalMessageInfo

func (m *AzureExistingSubnetParamType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *AzureExistingSubnetParamType) GetSubnetResourceGrp() string {
	if m != nil {
		return m.SubnetResourceGrp
	}
	return ""
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoice struct {
	// New Subnet
	//
	// x-displayName: "New Subnet"
	// Parameters for creating new subnet
	SubnetParam *AzureSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3" json:"subnet_param,omitempty"`
	// Existing Subnet Name
	//
	// x-displayName: "Existing Subnet Name"
	// Information about existing subnet
	ExistingSubnet *AzureExistingSubnetParamType `protobuf:"bytes,3,opt,name=existing_subnet,json=existingSubnet,proto3" json:"existing_subnet,omitempty"`
}

func (m *AzureSubnetChoice) Reset()      { *m = AzureSubnetChoice{} }
func (*AzureSubnetChoice) ProtoMessage() {}
func (*AzureSubnetChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{3}
}
func (m *AzureSubnetChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetChoice.Merge(m, src)
}
func (m *AzureSubnetChoice) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetChoice.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetChoice proto.InternalMessageInfo

func (m *AzureSubnetChoice) GetSubnetParam() *AzureSubnetParamType {
	if m != nil {
		return m.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoice) GetExistingSubnet() *AzureExistingSubnetParamType {
	if m != nil {
		return m.ExistingSubnet
	}
	return nil
}

// Terraform subnets Parameters
//
// x-displayName: "Terraform Subnet Parameters"
// Specifies subnet to be used or created in the cloud
type AzureSubnetType struct {
	// Volterra Subnet Id
	//
	// x-displayName: "Volterra Subnet ID"
	// Volterra subnet ID will be used to refer to this subnet in other TF parameters
	VoltSubnetId string `protobuf:"bytes,1,opt,name=volt_subnet_id,json=voltSubnetId,proto3" json:"volt_subnet_id,omitempty"`
	// Volterra Vnet id
	//
	// x-displayName: "Volterra Vnet id"
	// Vnet in which Cloud Instance is launched
	VoltVnetId string `protobuf:"bytes,2,opt,name=volt_vnet_id,json=voltVnetId,proto3" json:"volt_vnet_id,omitempty"`
	// Subnet Parameters
	//
	// x-displayName: "Subnet Parameters"
	// Subnet parameters for existing subnet or new subnet
	Subnet *AzureSubnetChoice `protobuf:"bytes,4,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,5,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *AzureSubnetType) Reset()      { *m = AzureSubnetType{} }
func (*AzureSubnetType) ProtoMessage() {}
func (*AzureSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{4}
}
func (m *AzureSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetType.Merge(m, src)
}
func (m *AzureSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetType proto.InternalMessageInfo

func (m *AzureSubnetType) GetVoltSubnetId() string {
	if m != nil {
		return m.VoltSubnetId
	}
	return ""
}

func (m *AzureSubnetType) GetVoltVnetId() string {
	if m != nil {
		return m.VoltVnetId
	}
	return ""
}

func (m *AzureSubnetType) GetSubnet() *AzureSubnetChoice {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *AzureSubnetType) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// Azure Vnet Parameters
//
// x-displayName: "AWS VPC Parameters"
// Parameters to create new AWS VPC
type AzureVnetParamsType struct {
	// Azure Resource Group
	//
	// x-displayName: "Resource Group"
	// Resource Group for this Vnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// Azure Vnet Name
	//
	// x-displayName: "Azure Vnet Name"
	// x-example: "MyVnet"
	// Name for your Azure Vnet
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 CIDR block"
	// x-example: "10.1.2.3.0/24"
	// IPv4 CIDR block for this Vnet. It has to private address space.
	PrimaryIpv4 string `protobuf:"bytes,3,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *AzureVnetParamsType) Reset()      { *m = AzureVnetParamsType{} }
func (*AzureVnetParamsType) ProtoMessage() {}
func (*AzureVnetParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{5}
}
func (m *AzureVnetParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetParamsType.Merge(m, src)
}
func (m *AzureVnetParamsType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetParamsType proto.InternalMessageInfo

func (m *AzureVnetParamsType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureVnetParamsType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AzureVnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// Azure Vnet Information
//
// x-displayName: "Azure Vnet Information"
// This defines Azure Vnet for a view
type AzureVnetInfoType struct {
	// New Vnet
	//
	// x-displayName: "New Vnet Parameters"
	// Parameters for creating new Vnet
	NewVnet *views.AzureVnetParamsType `protobuf:"bytes,1,opt,name=new_vnet,json=newVnet,proto3" json:"new_vnet,omitempty"`
	// Existing Vnet
	//
	// x-displayName: "Existing Vnet"
	// Information about existing Vnet
	Vnet *views.AzureVnetType `protobuf:"bytes,2,opt,name=vnet,proto3" json:"vnet,omitempty"`
}

func (m *AzureVnetInfoType) Reset()      { *m = AzureVnetInfoType{} }
func (*AzureVnetInfoType) ProtoMessage() {}
func (*AzureVnetInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{6}
}
func (m *AzureVnetInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetInfoType.Merge(m, src)
}
func (m *AzureVnetInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetInfoType proto.InternalMessageInfo

func (m *AzureVnetInfoType) GetNewVnet() *views.AzureVnetParamsType {
	if m != nil {
		return m.NewVnet
	}
	return nil
}

func (m *AzureVnetInfoType) GetVnet() *views.AzureVnetType {
	if m != nil {
		return m.Vnet
	}
	return nil
}

// Azure Availability Sets Information
//
// x-displayName: "Availability Sets Information"
// Provides information related to availability sets
type AvailabilitySetsInfoType struct {
	// Enable Availability Sets
	//
	// x-displayName: "Enable Availability Sets"
	// Flag to enable/disable availability sets
	Enable string `protobuf:"bytes,1,opt,name=enable,proto3" json:"enable,omitempty"`
	// Number of fault domains
	//
	// x-displayName: "Number of fault domains"
	// x-example: "1"
	// Namuber of fault domains to be used while creating the availability set
	FaultDomains uint32 `protobuf:"varint,4,opt,name=fault_domains,json=faultDomains,proto3" json:"fault_domains,omitempty"`
	// Number of update domains
	//
	// x-displayName: "Number of update domains"
	// x-example: "1"
	// Namuber of update domains to be used while creating the availability set
	UpdateDomains uint32 `protobuf:"varint,5,opt,name=update_domains,json=updateDomains,proto3" json:"update_domains,omitempty"`
}

func (m *AvailabilitySetsInfoType) Reset()      { *m = AvailabilitySetsInfoType{} }
func (*AvailabilitySetsInfoType) ProtoMessage() {}
func (*AvailabilitySetsInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{7}
}
func (m *AvailabilitySetsInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvailabilitySetsInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AvailabilitySetsInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvailabilitySetsInfoType.Merge(m, src)
}
func (m *AvailabilitySetsInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AvailabilitySetsInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AvailabilitySetsInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AvailabilitySetsInfoType proto.InternalMessageInfo

func (m *AvailabilitySetsInfoType) GetEnable() string {
	if m != nil {
		return m.Enable
	}
	return ""
}

func (m *AvailabilitySetsInfoType) GetFaultDomains() uint32 {
	if m != nil {
		return m.FaultDomains
	}
	return 0
}

func (m *AvailabilitySetsInfoType) GetUpdateDomains() uint32 {
	if m != nil {
		return m.UpdateDomains
	}
	return 0
}

// Terraform Azure Vnet Site Parameters
//
// x-displayName: "Terraform Object Parameters"
// Terraform parameters to create site in Azure.
type AzureVnetSiteType struct {
	// Site Name
	//
	// x-displayName: "Site Name"
	// Name of the site object to be created
	SiteName string `protobuf:"bytes,1,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	// Azure Unique Name
	//
	// x-displayName: "Azure Unique Name"
	// Azure unique name which will be used to create the cloud resource objects on azure"
	AzureName string `protobuf:"bytes,15,opt,name=azure_name,json=azureName,proto3" json:"azure_name,omitempty"`
	// Volterra Vnet Id
	//
	// x-displayName: "Volterra Vnet ID"
	// Volterra vnet ID will be used to refer to this vnet in other TF parameters
	VoltVnetId string `protobuf:"bytes,2,opt,name=volt_vnet_id,json=voltVnetId,proto3" json:"volt_vnet_id,omitempty"`
	// Fleet Label
	//
	// x-displayName: "Fleet Label"
	// Fleet Label to identify Fleet for this site. Fleet Label is assigned to site at registration approval
	FleetLabel string `protobuf:"bytes,3,opt,name=fleet_label,json=fleetLabel,proto3" json:"fleet_label,omitempty"`
	// Certified Hardware
	//
	// x-displayName: "Certified Hardware"
	// Certified Hardware to be used to create this site.
	CertifiedHw string `protobuf:"bytes,4,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// Azure Region
	//
	// x-displayName: "Azure Region"
	// Azure region
	AzureRegion string `protobuf:"bytes,5,opt,name=azure_region,json=azureRegion,proto3" json:"azure_region,omitempty"`
	// Azure Resource Group
	//
	// x-displayName: "Azure Resource Group"
	// Azure resource group
	AzureResourceGrp string `protobuf:"bytes,6,opt,name=azure_resource_grp,json=azureResourceGrp,proto3" json:"azure_resource_grp,omitempty"`
	// Vnet
	//
	// x-displayName: "Vnet"
	// Vnet parameters to instantiate this site
	Vnet *AzureVnetInfoType `protobuf:"bytes,7,opt,name=vnet,proto3" json:"vnet,omitempty"`
	// List of Subnets
	//
	// x-displayName: "List of Subnets"
	// List of Subnets that TF script needs
	Subnets []*AzureSubnetType `protobuf:"bytes,8,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// List of Master Nodes
	//
	// x-displayName: "List of Master Nodes"
	// List of Master Nodes in this Site that TF script needs to instantiate
	MasterNodes []*AzureInstanceType `protobuf:"bytes,9,rep,name=master_nodes,json=masterNodes,proto3" json:"master_nodes,omitempty"`
	// List of Inside VIP Port Config
	//
	// x-displayName: "List of Inside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	InsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,16,rep,name=inside_vip_port_config,json=insideVipPortConfig,proto3" json:"inside_vip_port_config,omitempty"`
	// List of Outside VIP Port Config
	//
	// x-displayName: "List of Outside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	OutsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,17,rep,name=outside_vip_port_config,json=outsideVipPortConfig,proto3" json:"outside_vip_port_config,omitempty"`
	// Worker Node Scaling
	//
	// x-displayName: "Worker Node Scaling"
	// Number of Maximum Worker Nodes for Auto Scale Configuration
	WorkerNodes uint32 `protobuf:"varint,14,opt,name=worker_nodes,json=workerNodes,proto3" json:"worker_nodes,omitempty"`
	// Gateway Type
	//
	// x-displayName: "Gateway Type"
	// Gateway Type
	GatewayType CloudGatewayType `protobuf:"varint,11,opt,name=gateway_type,json=gatewayType,proto3,enum=ves.io.schema.views.terraform_parameters.CloudGatewayType" json:"gateway_type,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// Public SSH key for accessing the site.
	SshKey string `protobuf:"bytes,13,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	// Azure Availability Sets Information
	//
	// x-displayName: "Availability Sets Information"
	// Provides information related to availability sets
	AvailabilitySet *AvailabilitySetsInfoType `protobuf:"bytes,18,opt,name=availability_set,json=availabilitySet,proto3" json:"availability_set,omitempty"`
	// Azure Tags
	//
	// x-displayName: "Azure Tags"
	// Azure Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources.
	Tags map[string]string `protobuf:"bytes,19,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AzureVnetSiteType) Reset()      { *m = AzureVnetSiteType{} }
func (*AzureVnetSiteType) ProtoMessage() {}
func (*AzureVnetSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{8}
}
func (m *AzureVnetSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetSiteType.Merge(m, src)
}
func (m *AzureVnetSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetSiteType proto.InternalMessageInfo

func (m *AzureVnetSiteType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *AzureVnetSiteType) GetAzureName() string {
	if m != nil {
		return m.AzureName
	}
	return ""
}

func (m *AzureVnetSiteType) GetVoltVnetId() string {
	if m != nil {
		return m.VoltVnetId
	}
	return ""
}

func (m *AzureVnetSiteType) GetFleetLabel() string {
	if m != nil {
		return m.FleetLabel
	}
	return ""
}

func (m *AzureVnetSiteType) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *AzureVnetSiteType) GetAzureRegion() string {
	if m != nil {
		return m.AzureRegion
	}
	return ""
}

func (m *AzureVnetSiteType) GetAzureResourceGrp() string {
	if m != nil {
		return m.AzureResourceGrp
	}
	return ""
}

func (m *AzureVnetSiteType) GetVnet() *AzureVnetInfoType {
	if m != nil {
		return m.Vnet
	}
	return nil
}

func (m *AzureVnetSiteType) GetSubnets() []*AzureSubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AzureVnetSiteType) GetMasterNodes() []*AzureInstanceType {
	if m != nil {
		return m.MasterNodes
	}
	return nil
}

func (m *AzureVnetSiteType) GetInsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.InsideVipPortConfig
	}
	return nil
}

func (m *AzureVnetSiteType) GetOutsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.OutsideVipPortConfig
	}
	return nil
}

func (m *AzureVnetSiteType) GetWorkerNodes() uint32 {
	if m != nil {
		return m.WorkerNodes
	}
	return 0
}

func (m *AzureVnetSiteType) GetGatewayType() CloudGatewayType {
	if m != nil {
		return m.GatewayType
	}
	return INGRESS_GATEWAY
}

func (m *AzureVnetSiteType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *AzureVnetSiteType) GetAvailabilitySet() *AvailabilitySetsInfoType {
	if m != nil {
		return m.AvailabilitySet
	}
	return nil
}

func (m *AzureVnetSiteType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func init() {
	proto.RegisterType((*AzureInstanceType)(nil), "ves.io.schema.views.terraform_parameters.AzureInstanceType")
	golang_proto.RegisterType((*AzureInstanceType)(nil), "ves.io.schema.views.terraform_parameters.AzureInstanceType")
	proto.RegisterType((*AzureSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetParamType")
	golang_proto.RegisterType((*AzureSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetParamType")
	proto.RegisterType((*AzureExistingSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureExistingSubnetParamType")
	golang_proto.RegisterType((*AzureExistingSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureExistingSubnetParamType")
	proto.RegisterType((*AzureSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetChoice")
	golang_proto.RegisterType((*AzureSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetChoice")
	proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetType")
	golang_proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetType")
	proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetParamsType")
	golang_proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetParamsType")
	proto.RegisterType((*AzureVnetInfoType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetInfoType")
	golang_proto.RegisterType((*AzureVnetInfoType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetInfoType")
	proto.RegisterType((*AvailabilitySetsInfoType)(nil), "ves.io.schema.views.terraform_parameters.AvailabilitySetsInfoType")
	golang_proto.RegisterType((*AvailabilitySetsInfoType)(nil), "ves.io.schema.views.terraform_parameters.AvailabilitySetsInfoType")
	proto.RegisterType((*AzureVnetSiteType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType")
	golang_proto.RegisterType((*AzureVnetSiteType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType.TagsEntry")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/terraform_parameters/azure_types.proto", fileDescriptor_cfa180cd722a5ccd)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/terraform_parameters/azure_types.proto", fileDescriptor_cfa180cd722a5ccd)
}

var fileDescriptor_cfa180cd722a5ccd = []byte{
	// 1392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x41, 0x73, 0x13, 0x47,
	0x16, 0xf6, 0x48, 0xb2, 0x2d, 0xf5, 0x48, 0xb2, 0xdc, 0x76, 0x2d, 0x83, 0x81, 0xc1, 0xa8, 0x38,
	0xa8, 0x28, 0x2c, 0xed, 0x7a, 0x29, 0x58, 0xd8, 0xaa, 0xad, 0xc5, 0x5e, 0x96, 0x95, 0x37, 0x01,
	0x6a, 0x4c, 0xb9, 0x2a, 0xa9, 0x0a, 0x53, 0x2d, 0xa9, 0x35, 0xee, 0xf2, 0x68, 0x7a, 0xaa, 0xa7,
	0x47, 0x42, 0x3e, 0xf1, 0x13, 0x38, 0x70, 0x4c, 0xee, 0xf9, 0x0d, 0x49, 0x0e, 0x1c, 0x73, 0xe4,
	0xc8, 0x31, 0xc8, 0x97, 0xe4, 0x90, 0x2a, 0x8e, 0xe4, 0x96, 0x9a, 0xd7, 0x2d, 0x79, 0x04, 0x22,
	0xd8, 0xce, 0x6d, 0xe6, 0x7b, 0xdf, 0x7b, 0xfd, 0xfa, 0xeb, 0xf7, 0x5e, 0x37, 0xba, 0xd3, 0xa7,
	0x51, 0x9d, 0xf1, 0x46, 0xd4, 0xde, 0xa7, 0x3d, 0xd2, 0xe8, 0x33, 0x3a, 0x88, 0x1a, 0x92, 0x0a,
	0x41, 0xba, 0x5c, 0xf4, 0xdc, 0x90, 0x08, 0xd2, 0xa3, 0x92, 0x8a, 0xa8, 0x41, 0x0e, 0x63, 0x41,
	0x5d, 0x39, 0x0c, 0x69, 0x54, 0x0f, 0x05, 0x97, 0x1c, 0xd7, 0x94, 0x6f, 0x5d, 0xf9, 0xd6, 0xc1,
	0xb7, 0x3e, 0xcb, 0x77, 0x6d, 0xc3, 0x63, 0x72, 0x3f, 0x6e, 0xd5, 0xdb, 0xbc, 0xd7, 0xf0, 0xb8,
	0xc7, 0x1b, 0x10, 0xa0, 0x15, 0x77, 0xe1, 0x0f, 0x7e, 0xe0, 0x4b, 0x05, 0x5e, 0x3b, 0xef, 0x71,
	0xee, 0xf9, 0xf4, 0x98, 0x45, 0x82, 0xa1, 0x36, 0x5d, 0x9f, 0xce, 0xb7, 0x4d, 0x85, 0x64, 0x5d,
	0x46, 0x3b, 0xee, 0x3e, 0x11, 0x9d, 0x01, 0x11, 0xb4, 0x91, 0xca, 0x70, 0xed, 0xc2, 0x34, 0x9b,
	0x87, 0x92, 0xf1, 0x60, 0x6c, 0x3c, 0x3f, 0x6d, 0x4c, 0xfb, 0x5d, 0x7c, 0x4f, 0x15, 0xe2, 0xb3,
	0x0e, 0x91, 0x54, 0x5b, 0xd7, 0x3f, 0xd4, 0xcc, 0x9d, 0x0e, 0x7d, 0x75, 0x96, 0xaa, 0x11, 0x93,
	0x53, 0xfa, 0xad, 0xdd, 0x38, 0xb1, 0xf6, 0x69, 0xaf, 0xcb, 0x33, 0xbd, 0x8e, 0x09, 0xd5, 0xdf,
	0x32, 0x68, 0xf9, 0x6e, 0x72, 0x58, 0xcd, 0x20, 0x92, 0x24, 0x68, 0xd3, 0xc7, 0xc3, 0x90, 0xe2,
	0x75, 0x54, 0xec, 0x73, 0x5f, 0xba, 0x01, 0xef, 0x50, 0x97, 0x75, 0x2c, 0x63, 0xdd, 0xa8, 0x15,
	0x1c, 0x94, 0x60, 0x0f, 0x78, 0x87, 0x36, 0x3b, 0x13, 0x46, 0x3f, 0xa0, 0x32, 0x61, 0x64, 0x8f,
	0x19, 0x7b, 0x01, 0x95, 0xcd, 0x0e, 0xae, 0xa1, 0x4a, 0x18, 0xb7, 0x7c, 0xd6, 0x76, 0xa3, 0xb8,
	0xa5, 0x59, 0x39, 0x60, 0x95, 0x15, 0xbe, 0x0b, 0x70, 0xb3, 0x83, 0xaf, 0xa1, 0xe5, 0x50, 0xb0,
	0x3e, 0x91, 0x34, 0x45, 0x9d, 0x07, 0xea, 0x92, 0x36, 0x4c, 0xb8, 0x57, 0x50, 0xb1, 0x47, 0xda,
	0xfb, 0x2c, 0x50, 0xea, 0x58, 0x0b, 0x40, 0x33, 0x35, 0x06, 0xc9, 0x5f, 0x40, 0x85, 0x0e, 0x8b,
	0x0e, 0xdc, 0x88, 0x1d, 0x52, 0x6b, 0x11, 0xec, 0xf9, 0x04, 0xd8, 0x65, 0x87, 0x14, 0x3f, 0x44,
	0x66, 0x8f, 0x88, 0x03, 0x2a, 0x43, 0x9f, 0xb4, 0xa9, 0x55, 0x58, 0x37, 0x6a, 0xe6, 0xe6, 0x46,
	0x7d, 0xba, 0x38, 0x3f, 0x2c, 0x94, 0xfa, 0xe7, 0xc7, 0x4e, 0x4e, 0x3a, 0x02, 0x2e, 0xa3, 0x0c,
	0x39, 0xb4, 0x10, 0x2c, 0x93, 0x21, 0x87, 0xf8, 0x12, 0x42, 0xa0, 0x5a, 0x9b, 0xc7, 0x81, 0xb4,
	0xcc, 0x75, 0xa3, 0x36, 0xef, 0x14, 0x12, 0x64, 0x3b, 0x01, 0x76, 0x72, 0xf9, 0x4c, 0x25, 0xbb,
	0x93, 0xcb, 0xe7, 0x2b, 0x85, 0xea, 0x73, 0x03, 0xad, 0x82, 0xf6, 0x6a, 0x77, 0x8f, 0x92, 0x23,
	0x84, 0x1d, 0xfc, 0x15, 0x95, 0x05, 0x8d, 0x78, 0x2c, 0xda, 0xd4, 0xf5, 0x04, 0x8f, 0x43, 0x75,
	0x00, 0x5b, 0x85, 0xef, 0x7e, 0x79, 0x99, 0xcd, 0x89, 0x8c, 0xf5, 0x6f, 0xa7, 0x34, 0x26, 0xdc,
	0x4f, 0xec, 0xb8, 0x8a, 0x72, 0x2c, 0xec, 0xdf, 0xb0, 0x32, 0xc0, 0x2b, 0xbf, 0xfb, 0xde, 0x98,
	0x4b, 0xb8, 0xf3, 0x22, 0xfb, 0xce, 0x30, 0x1c, 0xb0, 0x69, 0xce, 0x4d, 0x75, 0x54, 0x53, 0x9c,
	0x67, 0x19, 0xc5, 0xb9, 0x59, 0xe5, 0xe8, 0x22, 0x64, 0x74, 0xef, 0x29, 0x8b, 0x24, 0x0b, 0xbc,
	0xf7, 0x33, 0xbb, 0x8c, 0x4c, 0x7d, 0x44, 0x01, 0xe9, 0xd1, 0x71, 0x5d, 0x28, 0xe8, 0x01, 0xe9,
	0x51, 0x5c, 0x47, 0x2b, 0x9a, 0x90, 0xda, 0x41, 0xa8, 0xf2, 0x72, 0x96, 0x95, 0xc9, 0x99, 0xa4,
	0x1e, 0x56, 0x7f, 0x35, 0x74, 0xfd, 0xa9, 0x95, 0xb6, 0xf7, 0x39, 0x6b, 0x53, 0x4c, 0x50, 0x51,
	0x47, 0x81, 0xba, 0x86, 0x75, 0xcc, 0xcd, 0x7f, 0xd5, 0x4f, 0x3a, 0x43, 0xea, 0xb3, 0x64, 0x75,
	0x74, 0xea, 0x00, 0x60, 0x8e, 0x96, 0xa8, 0xde, 0xa4, 0xae, 0x3a, 0x10, 0xc6, 0xdc, 0xfc, 0xef,
	0x29, 0x57, 0xf9, 0x88, 0x54, 0x4e, 0x99, 0x4e, 0x19, 0xd4, 0xc9, 0x57, 0x5f, 0x64, 0xd0, 0x52,
	0x2a, 0x39, 0x10, 0xf5, 0x2a, 0x2a, 0x43, 0x2f, 0x1d, 0x17, 0xbf, 0xd2, 0x15, 0x3a, 0x6c, 0x52,
	0xf9, 0xef, 0x77, 0x5c, 0xe6, 0x83, 0x8e, 0xdb, 0x45, 0x0b, 0x7a, 0x27, 0x39, 0xd8, 0xc9, 0x3f,
	0xcf, 0xa4, 0x97, 0x3a, 0x02, 0x47, 0x87, 0xc2, 0x4f, 0x50, 0x99, 0x05, 0x92, 0x8a, 0x2e, 0x69,
	0xeb, 0x96, 0x4b, 0x3a, 0xb3, 0xbc, 0x79, 0xeb, 0xe4, 0xc1, 0x9b, 0x63, 0x7f, 0xd0, 0xa5, 0xc4,
	0xd2, 0xbf, 0x3b, 0xb9, 0x7c, 0xb6, 0x92, 0xab, 0x7e, 0x63, 0xa0, 0x15, 0xc8, 0x61, 0x6f, 0xac,
	0x61, 0x74, 0xc6, 0x4e, 0xb8, 0x82, 0x72, 0x50, 0x9a, 0xaa, 0x13, 0x4a, 0xe3, 0x2a, 0x57, 0x5c,
	0x30, 0xe1, 0xbf, 0xa1, 0x62, 0x28, 0x58, 0x8f, 0x88, 0xa1, 0x0b, 0x4d, 0x93, 0x9d, 0xd9, 0x34,
	0xa6, 0xe6, 0x34, 0xc3, 0xfe, 0x8d, 0xa4, 0x55, 0x97, 0x27, 0xf9, 0x35, 0x83, 0x2e, 0x87, 0xec,
	0xb6, 0x51, 0x3e, 0xa0, 0x03, 0x38, 0x11, 0x5d, 0xa2, 0xb5, 0x99, 0xaa, 0xcc, 0xd8, 0x99, 0xb3,
	0x18, 0xd0, 0x41, 0x02, 0xe1, 0x9b, 0x28, 0x07, 0x01, 0x32, 0x10, 0xa0, 0xfa, 0xc7, 0x01, 0xc0,
	0x15, 0xf8, 0xd5, 0x1f, 0x0c, 0x64, 0xdd, 0xed, 0x13, 0xe6, 0x93, 0x16, 0xf3, 0x99, 0x1c, 0xee,
	0x52, 0x19, 0x4d, 0x32, 0xbb, 0x8e, 0x16, 0x68, 0x40, 0x5a, 0xbe, 0x6e, 0xd1, 0xad, 0xd5, 0x64,
	0x63, 0x4b, 0xa2, 0xe4, 0xe4, 0xa4, 0x88, 0xa9, 0x33, 0xdf, 0x25, 0x7e, 0x44, 0x1d, 0xcd, 0xc1,
	0xb7, 0x50, 0xa9, 0x4b, 0x62, 0x5f, 0xba, 0x1d, 0xde, 0x23, 0x2c, 0x88, 0xa0, 0x7e, 0x4a, 0x5b,
	0x18, 0x84, 0xbb, 0x96, 0xa9, 0x19, 0xfa, 0xc3, 0xca, 0x3a, 0x45, 0x20, 0xfe, 0x47, 0xf1, 0xf0,
	0x6d, 0x54, 0x8e, 0xc3, 0xe4, 0xb2, 0x9b, 0x78, 0xce, 0x7f, 0xc4, 0x73, 0xd5, 0x29, 0x29, 0xa6,
	0x76, 0xad, 0xbe, 0x28, 0xa4, 0x14, 0xdd, 0x65, 0x72, 0x32, 0xbb, 0xe1, 0xe6, 0x4b, 0x4d, 0x97,
	0x7c, 0x02, 0xc0, 0x6c, 0xb9, 0x84, 0x90, 0x7a, 0x57, 0x80, 0x75, 0x09, 0xac, 0x05, 0x40, 0xc0,
	0xfc, 0xe9, 0x06, 0xb9, 0x8c, 0xcc, 0xae, 0x4f, 0xa9, 0x74, 0x7d, 0xd2, 0xa2, 0xfe, 0xf8, 0xce,
	0x02, 0xe8, 0xb3, 0x04, 0x49, 0x6e, 0x97, 0xd4, 0xec, 0x1f, 0xe8, 0xfb, 0xca, 0x9c, 0x60, 0xff,
	0x1b, 0x24, 0x14, 0x95, 0x84, 0xa0, 0x1e, 0xe3, 0x81, 0xbe, 0xa7, 0x4c, 0xc0, 0x1c, 0x80, 0xf0,
	0x75, 0x84, 0xc7, 0x94, 0xd4, 0x08, 0x54, 0x37, 0x55, 0x45, 0x13, 0x27, 0x13, 0x10, 0x3f, 0xd4,
	0xe7, 0xbf, 0x78, 0xa6, 0x9e, 0x4d, 0xd7, 0xa3, 0x2a, 0x0c, 0xbc, 0x8b, 0x16, 0x55, 0xef, 0x46,
	0x56, 0x7e, 0x3d, 0x5b, 0x33, 0x37, 0x6f, 0x9f, 0x69, 0x0e, 0xa8, 0x2a, 0xd5, 0x91, 0xf0, 0x93,
	0xe4, 0xde, 0x8d, 0x24, 0x15, 0xf0, 0x26, 0x88, 0xac, 0x02, 0x44, 0x3e, 0x6d, 0xb6, 0xe9, 0x47,
	0x46, 0x72, 0x8d, 0x26, 0x01, 0x93, 0x07, 0x45, 0x84, 0x7d, 0xf4, 0x17, 0x16, 0x44, 0xac, 0x43,
	0xdd, 0x3e, 0x0b, 0xdd, 0x90, 0x0b, 0xe9, 0xb6, 0x79, 0xd0, 0x65, 0x9e, 0x55, 0x81, 0x95, 0x4e,
	0x31, 0x6e, 0xf6, 0x9a, 0x8f, 0x1e, 0x71, 0x21, 0xb7, 0xc1, 0xdd, 0x59, 0x51, 0x61, 0xf7, 0x58,
	0x78, 0x0c, 0xe2, 0x00, 0x9d, 0xe3, 0xb1, 0x9c, 0xb9, 0xdc, 0xf2, 0x9f, 0x5b, 0x6e, 0x55, 0xc7,
	0x9d, 0x5e, 0xef, 0x0a, 0x2a, 0x0e, 0xb8, 0x38, 0x98, 0xa8, 0x57, 0x4e, 0xba, 0xc4, 0x31, 0x15,
	0xa6, 0x04, 0xf8, 0x0a, 0x15, 0x3d, 0x22, 0xe9, 0x80, 0x0c, 0xd5, 0x94, 0x35, 0x61, 0xca, 0xde,
	0x39, 0x79, 0x1e, 0xdb, 0x3e, 0x8f, 0x3b, 0xf7, 0x55, 0x08, 0xa5, 0xaf, 0x77, 0xfc, 0x83, 0xcf,
	0xa1, 0xc5, 0x28, 0xda, 0x77, 0x0f, 0xe8, 0xd0, 0x2a, 0x41, 0x21, 0x2e, 0x44, 0xd1, 0xfe, 0xff,
	0xe9, 0x10, 0xf7, 0x50, 0x85, 0xa4, 0xa6, 0x88, 0x1b, 0x51, 0x69, 0x61, 0x28, 0xc5, 0xad, 0x53,
	0x1c, 0xee, 0x47, 0xe6, 0x90, 0xb3, 0x44, 0xa6, 0x2d, 0xf8, 0x0b, 0x94, 0x93, 0xc4, 0x8b, 0xac,
	0x15, 0x90, 0xf9, 0xde, 0x19, 0xaa, 0x7d, 0x3c, 0x2b, 0xea, 0x8f, 0x89, 0x17, 0xdd, 0x0b, 0xa4,
	0x18, 0x3a, 0x10, 0x72, 0xed, 0x16, 0x2a, 0x4c, 0x20, 0x5c, 0x41, 0xd9, 0x64, 0xaf, 0x6a, 0x84,
	0x24, 0x9f, 0x78, 0x15, 0xcd, 0xf7, 0x89, 0x1f, 0xeb, 0x9b, 0xc1, 0x51, 0x3f, 0x77, 0x32, 0xff,
	0x30, 0x76, 0x72, 0x79, 0x54, 0x31, 0x77, 0x72, 0xf9, 0x62, 0xa5, 0xb4, 0xf5, 0xb5, 0xf1, 0xea,
	0x8d, 0x3d, 0xf7, 0xfa, 0x8d, 0x3d, 0xf7, 0xf6, 0x8d, 0x6d, 0x3c, 0x1b, 0xd9, 0xc6, 0xb7, 0x23,
	0xdb, 0xf8, 0x71, 0x64, 0x1b, 0xaf, 0x46, 0xb6, 0xf1, 0x7a, 0x64, 0x1b, 0x3f, 0x8d, 0x6c, 0xe3,
	0xe7, 0x91, 0x3d, 0xf7, 0x76, 0x64, 0x1b, 0xcf, 0x8f, 0xec, 0xb9, 0x97, 0x47, 0xb6, 0xf1, 0xea,
	0xc8, 0x9e, 0x7b, 0x7d, 0x64, 0xcf, 0x7d, 0xf9, 0xc4, 0xe3, 0xe1, 0x81, 0x57, 0x4f, 0x66, 0x4e,
	0xb2, 0x89, 0x7a, 0x9c, 0x7a, 0xa3, 0x6f, 0x84, 0x82, 0xf7, 0x59, 0x87, 0x8a, 0x8d, 0xb1, 0xb9,
	0x11, 0xb6, 0x3c, 0xde, 0xa0, 0x4f, 0xa5, 0x7e, 0x9e, 0x7f, 0xf2, 0x6d, 0xdf, 0x5a, 0x80, 0x57,
	0xfb, 0xdf, 0x7f, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x05, 0x95, 0xd1, 0x8a, 0x0d, 0x00, 0x00,
}

func (this *AzureInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureInstanceType)
	if !ok {
		that2, ok := that.(AzureInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltNodeId != that1.VoltNodeId {
		return false
	}
	if this.VoltVnetId != that1.VoltVnetId {
		return false
	}
	if this.PublicSubnetId != that1.PublicSubnetId {
		return false
	}
	if this.PrivateSubnetId != that1.PrivateSubnetId {
		return false
	}
	if this.MachineType != that1.MachineType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if !this.Marketplace.Equal(that1.Marketplace) {
		return false
	}
	if this.Az != that1.Az {
		return false
	}
	if this.NodeCount != that1.NodeCount {
		return false
	}
	return true
}
func (this *AzureSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetParamType)
	if !ok {
		that2, ok := that.(AzureSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	if this.Ipv6 != that1.Ipv6 {
		return false
	}
	return true
}
func (this *AzureExistingSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureExistingSubnetParamType)
	if !ok {
		that2, ok := that.(AzureExistingSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if this.SubnetResourceGrp != that1.SubnetResourceGrp {
		return false
	}
	return true
}
func (this *AzureSubnetChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoice)
	if !ok {
		that2, ok := that.(AzureSubnetChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	return true
}
func (this *AzureSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType)
	if !ok {
		that2, ok := that.(AzureSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltSubnetId != that1.VoltSubnetId {
		return false
	}
	if this.VoltVnetId != that1.VoltVnetId {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *AzureVnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType)
	if !ok {
		that2, ok := that.(AzureVnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *AzureVnetInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetInfoType)
	if !ok {
		that2, ok := that.(AzureVnetInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVnet.Equal(that1.NewVnet) {
		return false
	}
	if !this.Vnet.Equal(that1.Vnet) {
		return false
	}
	return true
}
func (this *AvailabilitySetsInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AvailabilitySetsInfoType)
	if !ok {
		that2, ok := that.(AvailabilitySetsInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enable != that1.Enable {
		return false
	}
	if this.FaultDomains != that1.FaultDomains {
		return false
	}
	if this.UpdateDomains != that1.UpdateDomains {
		return false
	}
	return true
}
func (this *AzureVnetSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetSiteType)
	if !ok {
		that2, ok := that.(AzureVnetSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	if this.AzureName != that1.AzureName {
		return false
	}
	if this.VoltVnetId != that1.VoltVnetId {
		return false
	}
	if this.FleetLabel != that1.FleetLabel {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if this.AzureRegion != that1.AzureRegion {
		return false
	}
	if this.AzureResourceGrp != that1.AzureResourceGrp {
		return false
	}
	if !this.Vnet.Equal(that1.Vnet) {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if len(this.MasterNodes) != len(that1.MasterNodes) {
		return false
	}
	for i := range this.MasterNodes {
		if !this.MasterNodes[i].Equal(that1.MasterNodes[i]) {
			return false
		}
	}
	if len(this.InsideVipPortConfig) != len(that1.InsideVipPortConfig) {
		return false
	}
	for i := range this.InsideVipPortConfig {
		if !this.InsideVipPortConfig[i].Equal(that1.InsideVipPortConfig[i]) {
			return false
		}
	}
	if len(this.OutsideVipPortConfig) != len(that1.OutsideVipPortConfig) {
		return false
	}
	for i := range this.OutsideVipPortConfig {
		if !this.OutsideVipPortConfig[i].Equal(that1.OutsideVipPortConfig[i]) {
			return false
		}
	}
	if this.WorkerNodes != that1.WorkerNodes {
		return false
	}
	if this.GatewayType != that1.GatewayType {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	if !this.AvailabilitySet.Equal(that1.AvailabilitySet) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *AzureInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&terraform_parameters.AzureInstanceType{")
	s = append(s, "VoltNodeId: "+fmt.Sprintf("%#v", this.VoltNodeId)+",\n")
	s = append(s, "VoltVnetId: "+fmt.Sprintf("%#v", this.VoltVnetId)+",\n")
	s = append(s, "PublicSubnetId: "+fmt.Sprintf("%#v", this.PublicSubnetId)+",\n")
	s = append(s, "PrivateSubnetId: "+fmt.Sprintf("%#v", this.PrivateSubnetId)+",\n")
	s = append(s, "MachineType: "+fmt.Sprintf("%#v", this.MachineType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	if this.Marketplace != nil {
		s = append(s, "Marketplace: "+fmt.Sprintf("%#v", this.Marketplace)+",\n")
	}
	s = append(s, "Az: "+fmt.Sprintf("%#v", this.Az)+",\n")
	s = append(s, "NodeCount: "+fmt.Sprintf("%#v", this.NodeCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.AzureSubnetParamType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureExistingSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AzureExistingSubnetParamType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "SubnetResourceGrp: "+fmt.Sprintf("%#v", this.SubnetResourceGrp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AzureSubnetChoice{")
	if this.SubnetParam != nil {
		s = append(s, "SubnetParam: "+fmt.Sprintf("%#v", this.SubnetParam)+",\n")
	}
	if this.ExistingSubnet != nil {
		s = append(s, "ExistingSubnet: "+fmt.Sprintf("%#v", this.ExistingSubnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&terraform_parameters.AzureSubnetType{")
	s = append(s, "VoltSubnetId: "+fmt.Sprintf("%#v", this.VoltSubnetId)+",\n")
	s = append(s, "VoltVnetId: "+fmt.Sprintf("%#v", this.VoltVnetId)+",\n")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.AzureVnetParamsType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AzureVnetInfoType{")
	if this.NewVnet != nil {
		s = append(s, "NewVnet: "+fmt.Sprintf("%#v", this.NewVnet)+",\n")
	}
	if this.Vnet != nil {
		s = append(s, "Vnet: "+fmt.Sprintf("%#v", this.Vnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AvailabilitySetsInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.AvailabilitySetsInfoType{")
	s = append(s, "Enable: "+fmt.Sprintf("%#v", this.Enable)+",\n")
	s = append(s, "FaultDomains: "+fmt.Sprintf("%#v", this.FaultDomains)+",\n")
	s = append(s, "UpdateDomains: "+fmt.Sprintf("%#v", this.UpdateDomains)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&terraform_parameters.AzureVnetSiteType{")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "AzureName: "+fmt.Sprintf("%#v", this.AzureName)+",\n")
	s = append(s, "VoltVnetId: "+fmt.Sprintf("%#v", this.VoltVnetId)+",\n")
	s = append(s, "FleetLabel: "+fmt.Sprintf("%#v", this.FleetLabel)+",\n")
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	s = append(s, "AzureRegion: "+fmt.Sprintf("%#v", this.AzureRegion)+",\n")
	s = append(s, "AzureResourceGrp: "+fmt.Sprintf("%#v", this.AzureResourceGrp)+",\n")
	if this.Vnet != nil {
		s = append(s, "Vnet: "+fmt.Sprintf("%#v", this.Vnet)+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.MasterNodes != nil {
		s = append(s, "MasterNodes: "+fmt.Sprintf("%#v", this.MasterNodes)+",\n")
	}
	if this.InsideVipPortConfig != nil {
		s = append(s, "InsideVipPortConfig: "+fmt.Sprintf("%#v", this.InsideVipPortConfig)+",\n")
	}
	if this.OutsideVipPortConfig != nil {
		s = append(s, "OutsideVipPortConfig: "+fmt.Sprintf("%#v", this.OutsideVipPortConfig)+",\n")
	}
	s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	s = append(s, "GatewayType: "+fmt.Sprintf("%#v", this.GatewayType)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	if this.AvailabilitySet != nil {
		s = append(s, "AvailabilitySet: "+fmt.Sprintf("%#v", this.AvailabilitySet)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAzureTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AzureInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeCount != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Az) > 0 {
		i -= len(m.Az)
		copy(dAtA[i:], m.Az)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Az)))
		i--
		dAtA[i] = 0x52
	}
	if m.Marketplace != nil {
		{
			size, err := m.Marketplace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DiskSize) > 0 {
		i -= len(m.DiskSize)
		copy(dAtA[i:], m.DiskSize)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.DiskSize)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MachineType) > 0 {
		i -= len(m.MachineType)
		copy(dAtA[i:], m.MachineType)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.MachineType)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PrivateSubnetId) > 0 {
		i -= len(m.PrivateSubnetId)
		copy(dAtA[i:], m.PrivateSubnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.PrivateSubnetId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicSubnetId) > 0 {
		i -= len(m.PublicSubnetId)
		copy(dAtA[i:], m.PublicSubnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.PublicSubnetId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltVnetId) > 0 {
		i -= len(m.VoltVnetId)
		copy(dAtA[i:], m.VoltVnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltVnetId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltNodeId) > 0 {
		i -= len(m.VoltNodeId)
		copy(dAtA[i:], m.VoltNodeId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6) > 0 {
		i -= len(m.Ipv6)
		copy(dAtA[i:], m.Ipv6)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Ipv6)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureExistingSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureExistingSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureExistingSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetResourceGrp) > 0 {
		i -= len(m.SubnetResourceGrp)
		copy(dAtA[i:], m.SubnetResourceGrp)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SubnetResourceGrp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubnetName) > 0 {
		i -= len(m.SubnetName)
		copy(dAtA[i:], m.SubnetName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SubnetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExistingSubnet != nil {
		{
			size, err := m.ExistingSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x28
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltVnetId) > 0 {
		i -= len(m.VoltVnetId)
		copy(dAtA[i:], m.VoltVnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltVnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VoltSubnetId) > 0 {
		i -= len(m.VoltSubnetId)
		copy(dAtA[i:], m.VoltSubnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltSubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrimaryIpv4) > 0 {
		i -= len(m.PrimaryIpv4)
		copy(dAtA[i:], m.PrimaryIpv4)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vnet != nil {
		{
			size, err := m.Vnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewVnet != nil {
		{
			size, err := m.NewVnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AvailabilitySetsInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailabilitySetsInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvailabilitySetsInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateDomains != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.UpdateDomains))
		i--
		dAtA[i] = 0x28
	}
	if m.FaultDomains != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.FaultDomains))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Enable) > 0 {
		i -= len(m.Enable)
		copy(dAtA[i:], m.Enable)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Enable)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAzureTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintAzureTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAzureTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AvailabilitySet != nil {
		{
			size, err := m.AvailabilitySet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for iNdEx := len(m.OutsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.InsideVipPortConfig) > 0 {
		for iNdEx := len(m.InsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.AzureName) > 0 {
		i -= len(m.AzureName)
		copy(dAtA[i:], m.AzureName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureName)))
		i--
		dAtA[i] = 0x7a
	}
	if m.WorkerNodes != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.WorkerNodes))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GatewayType != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.GatewayType))
		i--
		dAtA[i] = 0x58
	}
	if len(m.MasterNodes) > 0 {
		for iNdEx := len(m.MasterNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MasterNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Vnet != nil {
		{
			size, err := m.Vnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AzureResourceGrp) > 0 {
		i -= len(m.AzureResourceGrp)
		copy(dAtA[i:], m.AzureResourceGrp)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureResourceGrp)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AzureRegion) > 0 {
		i -= len(m.AzureRegion)
		copy(dAtA[i:], m.AzureRegion)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureRegion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CertifiedHw) > 0 {
		i -= len(m.CertifiedHw)
		copy(dAtA[i:], m.CertifiedHw)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FleetLabel) > 0 {
		i -= len(m.FleetLabel)
		copy(dAtA[i:], m.FleetLabel)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.FleetLabel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltVnetId) > 0 {
		i -= len(m.VoltVnetId)
		copy(dAtA[i:], m.VoltVnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltVnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAzureTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAzureTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AzureInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltNodeId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VoltVnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.PublicSubnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.PrivateSubnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.MachineType)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Marketplace != nil {
		l = m.Marketplace.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Az)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovAzureTypes(uint64(m.NodeCount))
	}
	return n
}

func (m *AzureSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Ipv6)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureExistingSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.SubnetResourceGrp)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureSubnetChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltSubnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VoltVnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovAzureTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *AzureVnetParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVnet != nil {
		l = m.NewVnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Vnet != nil {
		l = m.Vnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AvailabilitySetsInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Enable)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.FaultDomains != 0 {
		n += 1 + sovAzureTypes(uint64(m.FaultDomains))
	}
	if m.UpdateDomains != 0 {
		n += 1 + sovAzureTypes(uint64(m.UpdateDomains))
	}
	return n
}

func (m *AzureVnetSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VoltVnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.FleetLabel)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AzureRegion)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AzureResourceGrp)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Vnet != nil {
		l = m.Vnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	if len(m.MasterNodes) > 0 {
		for _, e := range m.MasterNodes {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	if m.GatewayType != 0 {
		n += 1 + sovAzureTypes(uint64(m.GatewayType))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.WorkerNodes != 0 {
		n += 1 + sovAzureTypes(uint64(m.WorkerNodes))
	}
	l = len(m.AzureName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.InsideVipPortConfig) > 0 {
		for _, e := range m.InsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAzureTypes(uint64(l))
		}
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for _, e := range m.OutsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAzureTypes(uint64(l))
		}
	}
	if m.AvailabilitySet != nil {
		l = m.AvailabilitySet.Size()
		n += 2 + l + sovAzureTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAzureTypes(uint64(len(k))) + 1 + len(v) + sovAzureTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovAzureTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func sovAzureTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAzureTypes(x uint64) (n int) {
	return sovAzureTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AzureInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureInstanceType{`,
		`VoltNodeId:` + fmt.Sprintf("%v", this.VoltNodeId) + `,`,
		`VoltVnetId:` + fmt.Sprintf("%v", this.VoltVnetId) + `,`,
		`PublicSubnetId:` + fmt.Sprintf("%v", this.PublicSubnetId) + `,`,
		`PrivateSubnetId:` + fmt.Sprintf("%v", this.PrivateSubnetId) + `,`,
		`MachineType:` + fmt.Sprintf("%v", this.MachineType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`Marketplace:` + strings.Replace(fmt.Sprintf("%v", this.Marketplace), "Marketplace", "certified_hardware.Marketplace", 1) + `,`,
		`Az:` + fmt.Sprintf("%v", this.Az) + `,`,
		`NodeCount:` + fmt.Sprintf("%v", this.NodeCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetParamType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`Ipv6:` + fmt.Sprintf("%v", this.Ipv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureExistingSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureExistingSubnetParamType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`SubnetResourceGrp:` + fmt.Sprintf("%v", this.SubnetResourceGrp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoice{`,
		`SubnetParam:` + strings.Replace(this.SubnetParam.String(), "AzureSubnetParamType", "AzureSubnetParamType", 1) + `,`,
		`ExistingSubnet:` + strings.Replace(this.ExistingSubnet.String(), "AzureExistingSubnetParamType", "AzureExistingSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType{`,
		`VoltSubnetId:` + fmt.Sprintf("%v", this.VoltSubnetId) + `,`,
		`VoltVnetId:` + fmt.Sprintf("%v", this.VoltVnetId) + `,`,
		`Subnet:` + strings.Replace(this.Subnet.String(), "AzureSubnetChoice", "AzureSubnetChoice", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetInfoType{`,
		`NewVnet:` + strings.Replace(fmt.Sprintf("%v", this.NewVnet), "AzureVnetParamsType", "views.AzureVnetParamsType", 1) + `,`,
		`Vnet:` + strings.Replace(fmt.Sprintf("%v", this.Vnet), "AzureVnetType", "views.AzureVnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AvailabilitySetsInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AvailabilitySetsInfoType{`,
		`Enable:` + fmt.Sprintf("%v", this.Enable) + `,`,
		`FaultDomains:` + fmt.Sprintf("%v", this.FaultDomains) + `,`,
		`UpdateDomains:` + fmt.Sprintf("%v", this.UpdateDomains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetSiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*AzureSubnetType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "AzureSubnetType", "AzureSubnetType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	repeatedStringForMasterNodes := "[]*AzureInstanceType{"
	for _, f := range this.MasterNodes {
		repeatedStringForMasterNodes += strings.Replace(f.String(), "AzureInstanceType", "AzureInstanceType", 1) + ","
	}
	repeatedStringForMasterNodes += "}"
	repeatedStringForInsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.InsideVipPortConfig {
		repeatedStringForInsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForInsideVipPortConfig += "}"
	repeatedStringForOutsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.OutsideVipPortConfig {
		repeatedStringForOutsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForOutsideVipPortConfig += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AzureVnetSiteType{`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`VoltVnetId:` + fmt.Sprintf("%v", this.VoltVnetId) + `,`,
		`FleetLabel:` + fmt.Sprintf("%v", this.FleetLabel) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`AzureRegion:` + fmt.Sprintf("%v", this.AzureRegion) + `,`,
		`AzureResourceGrp:` + fmt.Sprintf("%v", this.AzureResourceGrp) + `,`,
		`Vnet:` + strings.Replace(this.Vnet.String(), "AzureVnetInfoType", "AzureVnetInfoType", 1) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`MasterNodes:` + repeatedStringForMasterNodes + `,`,
		`GatewayType:` + fmt.Sprintf("%v", this.GatewayType) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`AzureName:` + fmt.Sprintf("%v", this.AzureName) + `,`,
		`InsideVipPortConfig:` + repeatedStringForInsideVipPortConfig + `,`,
		`OutsideVipPortConfig:` + repeatedStringForOutsideVipPortConfig + `,`,
		`AvailabilitySet:` + strings.Replace(this.AvailabilitySet.String(), "AvailabilitySetsInfoType", "AvailabilitySetsInfoType", 1) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAzureTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AzureInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marketplace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marketplace == nil {
				m.Marketplace = &certified_hardware.Marketplace{}
			}
			if err := m.Marketplace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Az", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Az = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureExistingSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureExistingSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureExistingSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetResourceGrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetParam == nil {
				m.SubnetParam = &AzureSubnetParamType{}
			}
			if err := m.SubnetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingSubnet == nil {
				m.ExistingSubnet = &AzureExistingSubnetParamType{}
			}
			if err := m.ExistingSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &AzureSubnetChoice{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewVnet == nil {
				m.NewVnet = &views.AzureVnetParamsType{}
			}
			if err := m.NewVnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vnet == nil {
				m.Vnet = &views.AzureVnetType{}
			}
			if err := m.Vnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailabilitySetsInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailabilitySetsInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailabilitySetsInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultDomains", wireType)
			}
			m.FaultDomains = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaultDomains |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDomains", wireType)
			}
			m.UpdateDomains = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDomains |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FleetLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureResourceGrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vnet == nil {
				m.Vnet = &AzureVnetInfoType{}
			}
			if err := m.Vnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &AzureSubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodes = append(m.MasterNodes, &AzureInstanceType{})
			if err := m.MasterNodes[len(m.MasterNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayType", wireType)
			}
			m.GatewayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayType |= CloudGatewayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodes", wireType)
			}
			m.WorkerNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVipPortConfig = append(m.InsideVipPortConfig, &VIPPortConfig{})
			if err := m.InsideVipPortConfig[len(m.InsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVipPortConfig = append(m.OutsideVipPortConfig, &VIPPortConfig{})
			if err := m.OutsideVipPortConfig[len(m.OutsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilitySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvailabilitySet == nil {
				m.AvailabilitySet = &AvailabilitySetsInfoType{}
			}
			if err := m.AvailabilitySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAzureTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAzureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAzureTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAzureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAzureTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAzureTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAzureTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAzureTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAzureTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAzureTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAzureTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAzureTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAzureTypes = fmt.Errorf("proto: unexpected end of group")
)
