// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/network_policy_rule/types.proto

package network_policy_rule

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Network Policy Rule Action
//
// x-displayName: "Network Policy Rule Action"
// Network policy rule action configures the action to be taken on rule match
type NetworkPolicyRuleAction int32

const (
	// x-displayName: "Deny"
	// Apply deny action on rule match
	DENY NetworkPolicyRuleAction = 0
	// x-displayName: "Allow"
	// Apply allow action on rule match
	ALLOW NetworkPolicyRuleAction = 1
)

var NetworkPolicyRuleAction_name = map[int32]string{
	0: "DENY",
	1: "ALLOW",
}

var NetworkPolicyRuleAction_value = map[string]int32{
	"DENY":  0,
	"ALLOW": 1,
}

func (NetworkPolicyRuleAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{0}
}

// Log Action
//
// x-displayName: "Log Action"
// Choice to choose logging or no logging
// This works together with option selected via NetworkPolicyRuleAction or any other action specified
// x-example: (No Selection in NetworkPolicyRuleAction + AdvancedAction as LOG) = LOG Only, (ALLOW/DENY in NetworkPolicyRuleAction + AdvancedAction as LOG) = Log and Allow/Deny, (ALLOW/DENY in NetworkPolicyRuleAction + NOLOG in AdvancedAction) = Allow/Deny with no log
type LogAction int32

const (
	// x-displayName: "Do Not Log"
	// Don't sample the traffic hitting the rule
	NOLOG LogAction = 0
	// x-displayName: "Log"
	// Sample the traffic hitting the rule
	LOG LogAction = 1
)

var LogAction_name = map[int32]string{
	0: "NOLOG",
	1: "LOG",
}

var LogAction_value = map[string]int32{
	"NOLOG": 0,
	"LOG":   1,
}

func (LogAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{1}
}

// Network Policy Rule Action
//
// x-displayName: "Network Policy Rule Action"
// Network policy rule action configures the action to be taken on rule match
type NetworkPolicyPBRRuleAction struct {
	// Forwarding Class
	//
	// x-displayName: "Forwarding Class"
	// Ordered list of forwarding class to use for traffic that match enclosing rule
	// Action valid only when policy is part of PBR.
	ForwardingClass []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=forwarding_class,json=forwardingClass,proto3" json:"forwarding_class,omitempty"`
}

func (m *NetworkPolicyPBRRuleAction) Reset()      { *m = NetworkPolicyPBRRuleAction{} }
func (*NetworkPolicyPBRRuleAction) ProtoMessage() {}
func (*NetworkPolicyPBRRuleAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{0}
}
func (m *NetworkPolicyPBRRuleAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPolicyPBRRuleAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkPolicyPBRRuleAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPolicyPBRRuleAction.Merge(m, src)
}
func (m *NetworkPolicyPBRRuleAction) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPolicyPBRRuleAction) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPolicyPBRRuleAction.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPolicyPBRRuleAction proto.InternalMessageInfo

func (m *NetworkPolicyPBRRuleAction) GetForwardingClass() []*schema.ObjectRefType {
	if m != nil {
		return m.ForwardingClass
	}
	return nil
}

// Network Policy Rule Advanced Action
//
// x-displayName: "Network Policy Rule Advanced Action"
// Network Policy Rule Advanced Action provides additional options along with RuleAction and PBRRuleAction
type NetworkPolicyRuleAdvancedAction struct {
	// Action
	//
	// x-displayName: "Logging Action"
	// Enable or disable logging.
	Action LogAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.LogAction" json:"action,omitempty"`
}

func (m *NetworkPolicyRuleAdvancedAction) Reset()      { *m = NetworkPolicyRuleAdvancedAction{} }
func (*NetworkPolicyRuleAdvancedAction) ProtoMessage() {}
func (*NetworkPolicyRuleAdvancedAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{1}
}
func (m *NetworkPolicyRuleAdvancedAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPolicyRuleAdvancedAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkPolicyRuleAdvancedAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPolicyRuleAdvancedAction.Merge(m, src)
}
func (m *NetworkPolicyRuleAdvancedAction) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPolicyRuleAdvancedAction) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPolicyRuleAdvancedAction.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPolicyRuleAdvancedAction proto.InternalMessageInfo

func (m *NetworkPolicyRuleAdvancedAction) GetAction() LogAction {
	if m != nil {
		return m.Action
	}
	return NOLOG
}

// Network Policy Rule Specification
//
// x-displayName: "Specification"
// Desired state of the network policy rule
type GlobalSpecType struct {
	// Action
	//
	// x-displayName: "Action"
	// Action to be taken at rule match. Currently supported actions are Allow and  Deny
	Action NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	// ports
	//
	// x-displayName: "List of Port Ranges"
	// x-example: "100-200"
	// List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192
	Ports []string `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	// protocol
	//
	// x-displayName: "Protocol"
	// x-example: "tcp"
	// Protocol in IP packet to be used as match criteria
	// Values are tcp, udp, and icmp
	Protocol string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Remote Endpoint
	//
	// x-displayName: "Remote Endpoint"
	// Remote endpoint is the other endpoint for ingress or egress session with local endpoint
	// of network policy. If network policy rule is a ingress rule in network policy then remote
	// endpoint indicates the source endpoint from  which session is initiated. If network policy rule
	// is a egress rule in network policy then remote endpoint indicates the destination endpoint to which
	// session is initiated. Not specifying any endpoint will result in creation of ANY endpoint
	//
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*GlobalSpecType_Prefix
	//	*GlobalSpecType_PrefixSelector
	//	*GlobalSpecType_IpPrefixSet
	RemoteEndpoint isGlobalSpecType_RemoteEndpoint `protobuf_oneof:"remote_endpoint"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: label_matcher is "app" and say prefix_selector is "app == web, site in (abc, xyz)" then only label app will be matched and not site
	//
	// List of label keys to be matched in prefix_selector configured in remote_endpoint
	LabelMatcher *schema.LabelMatcherType `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	// Policy Based Routing Action
	//
	// x-displayName: "Policy Based Routing Action"
	// Action valid only when policy is part of PBR.
	PbrAction *NetworkPolicyPBRRuleAction `protobuf:"bytes,8,opt,name=pbr_action,json=pbrAction,proto3" json:"pbr_action,omitempty"`
	// advanced_action
	//
	// x-displayName: "Logging Action"
	// Enable or disable logging.
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction,proto3" json:"advanced_action,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{2}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_RemoteEndpoint interface {
	isGlobalSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Prefix struct {
	Prefix *schema.PrefixListType `protobuf:"bytes,4,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type GlobalSpecType_PrefixSelector struct {
	PrefixSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,proto3,oneof" json:"prefix_selector,omitempty"`
}
type GlobalSpecType_IpPrefixSet struct {
	IpPrefixSet *schema.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,proto3,oneof" json:"ip_prefix_set,omitempty"`
}

func (*GlobalSpecType_Prefix) isGlobalSpecType_RemoteEndpoint()         {}
func (*GlobalSpecType_PrefixSelector) isGlobalSpecType_RemoteEndpoint() {}
func (*GlobalSpecType_IpPrefixSet) isGlobalSpecType_RemoteEndpoint()    {}

func (m *GlobalSpecType) GetRemoteEndpoint() isGlobalSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *GlobalSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *GlobalSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *GlobalSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GlobalSpecType) GetPrefix() *schema.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*GlobalSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GlobalSpecType) GetPrefixSelector() *schema.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*GlobalSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GlobalSpecType) GetIpPrefixSet() *schema.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*GlobalSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *GlobalSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPbrAction() *NetworkPolicyPBRRuleAction {
	if m != nil {
		return m.PbrAction
	}
	return nil
}

func (m *GlobalSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_Prefix)(nil),
		(*GlobalSpecType_PrefixSelector)(nil),
		(*GlobalSpecType_IpPrefixSet)(nil),
	}
}

// Create Network Policy Rule
//
// x-displayName: "Create Network Policy Rule"
// Creates a network policy rule with configured parameters in specified namespace
type CreateSpecType struct {
	Action   NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	Ports    []string                `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	Protocol string                  `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*CreateSpecType_Prefix
	//	*CreateSpecType_PrefixSelector
	//	*CreateSpecType_IpPrefixSet
	RemoteEndpoint isCreateSpecType_RemoteEndpoint  `protobuf_oneof:"remote_endpoint"`
	LabelMatcher   *schema.LabelMatcherType         `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction,proto3" json:"advanced_action,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{3}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_RemoteEndpoint interface {
	isCreateSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Prefix struct {
	Prefix *schema.PrefixListType `protobuf:"bytes,4,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type CreateSpecType_PrefixSelector struct {
	PrefixSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,proto3,oneof" json:"prefix_selector,omitempty"`
}
type CreateSpecType_IpPrefixSet struct {
	IpPrefixSet *schema.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,proto3,oneof" json:"ip_prefix_set,omitempty"`
}

func (*CreateSpecType_Prefix) isCreateSpecType_RemoteEndpoint()         {}
func (*CreateSpecType_PrefixSelector) isCreateSpecType_RemoteEndpoint() {}
func (*CreateSpecType_IpPrefixSet) isCreateSpecType_RemoteEndpoint()    {}

func (m *CreateSpecType) GetRemoteEndpoint() isCreateSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *CreateSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *CreateSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *CreateSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *CreateSpecType) GetPrefix() *schema.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*CreateSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *CreateSpecType) GetPrefixSelector() *schema.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*CreateSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *CreateSpecType) GetIpPrefixSet() *schema.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*CreateSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *CreateSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_Prefix)(nil),
		(*CreateSpecType_PrefixSelector)(nil),
		(*CreateSpecType_IpPrefixSet)(nil),
	}
}

// Replace Network Policy Rule
//
// x-displayName: "Replace Network Policy Rule"
// Replaces a network policy rule with configured parameters in specified namespace
type ReplaceSpecType struct {
	Action   NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	Ports    []string                `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	Protocol string                  `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*ReplaceSpecType_Prefix
	//	*ReplaceSpecType_PrefixSelector
	//	*ReplaceSpecType_IpPrefixSet
	RemoteEndpoint isReplaceSpecType_RemoteEndpoint `protobuf_oneof:"remote_endpoint"`
	LabelMatcher   *schema.LabelMatcherType         `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction,proto3" json:"advanced_action,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{4}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_RemoteEndpoint interface {
	isReplaceSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Prefix struct {
	Prefix *schema.PrefixListType `protobuf:"bytes,4,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type ReplaceSpecType_PrefixSelector struct {
	PrefixSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,proto3,oneof" json:"prefix_selector,omitempty"`
}
type ReplaceSpecType_IpPrefixSet struct {
	IpPrefixSet *schema.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,proto3,oneof" json:"ip_prefix_set,omitempty"`
}

func (*ReplaceSpecType_Prefix) isReplaceSpecType_RemoteEndpoint()         {}
func (*ReplaceSpecType_PrefixSelector) isReplaceSpecType_RemoteEndpoint() {}
func (*ReplaceSpecType_IpPrefixSet) isReplaceSpecType_RemoteEndpoint()    {}

func (m *ReplaceSpecType) GetRemoteEndpoint() isReplaceSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *ReplaceSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *ReplaceSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ReplaceSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ReplaceSpecType) GetPrefix() *schema.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*ReplaceSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *ReplaceSpecType) GetPrefixSelector() *schema.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*ReplaceSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetIpPrefixSet() *schema.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*ReplaceSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *ReplaceSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_Prefix)(nil),
		(*ReplaceSpecType_PrefixSelector)(nil),
		(*ReplaceSpecType_IpPrefixSet)(nil),
	}
}

// Get Network Policy Rule
//
// x-displayName: "Get Network Policy Rule"
// Get a network policy rule in specified namespace
type GetSpecType struct {
	Action   NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	Ports    []string                `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	Protocol string                  `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Types that are valid to be assigned to RemoteEndpoint:
	//	*GetSpecType_Prefix
	//	*GetSpecType_PrefixSelector
	//	*GetSpecType_IpPrefixSet
	RemoteEndpoint isGetSpecType_RemoteEndpoint     `protobuf_oneof:"remote_endpoint"`
	LabelMatcher   *schema.LabelMatcherType         `protobuf:"bytes,6,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	AdvancedAction *NetworkPolicyRuleAdvancedAction `protobuf:"bytes,10,opt,name=advanced_action,json=advancedAction,proto3" json:"advanced_action,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8508d684cd4d0a5f, []int{5}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_RemoteEndpoint interface {
	isGetSpecType_RemoteEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Prefix struct {
	Prefix *schema.PrefixListType `protobuf:"bytes,4,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type GetSpecType_PrefixSelector struct {
	PrefixSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=prefix_selector,json=prefixSelector,proto3,oneof" json:"prefix_selector,omitempty"`
}
type GetSpecType_IpPrefixSet struct {
	IpPrefixSet *schema.IpPrefixSetRefType `protobuf:"bytes,7,opt,name=ip_prefix_set,json=ipPrefixSet,proto3,oneof" json:"ip_prefix_set,omitempty"`
}

func (*GetSpecType_Prefix) isGetSpecType_RemoteEndpoint()         {}
func (*GetSpecType_PrefixSelector) isGetSpecType_RemoteEndpoint() {}
func (*GetSpecType_IpPrefixSet) isGetSpecType_RemoteEndpoint()    {}

func (m *GetSpecType) GetRemoteEndpoint() isGetSpecType_RemoteEndpoint {
	if m != nil {
		return m.RemoteEndpoint
	}
	return nil
}

func (m *GetSpecType) GetAction() NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return DENY
}

func (m *GetSpecType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *GetSpecType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *GetSpecType) GetPrefix() *schema.PrefixListType {
	if x, ok := m.GetRemoteEndpoint().(*GetSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GetSpecType) GetPrefixSelector() *schema.LabelSelectorType {
	if x, ok := m.GetRemoteEndpoint().(*GetSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GetSpecType) GetIpPrefixSet() *schema.IpPrefixSetRefType {
	if x, ok := m.GetRemoteEndpoint().(*GetSpecType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *GetSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GetSpecType) GetAdvancedAction() *NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvancedAction
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_Prefix)(nil),
		(*GetSpecType_PrefixSelector)(nil),
		(*GetSpecType_IpPrefixSet)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.network_policy_rule.NetworkPolicyRuleAction", NetworkPolicyRuleAction_name, NetworkPolicyRuleAction_value)
	golang_proto.RegisterEnum("ves.io.schema.network_policy_rule.NetworkPolicyRuleAction", NetworkPolicyRuleAction_name, NetworkPolicyRuleAction_value)
	proto.RegisterEnum("ves.io.schema.network_policy_rule.LogAction", LogAction_name, LogAction_value)
	golang_proto.RegisterEnum("ves.io.schema.network_policy_rule.LogAction", LogAction_name, LogAction_value)
	proto.RegisterType((*NetworkPolicyPBRRuleAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyPBRRuleAction")
	golang_proto.RegisterType((*NetworkPolicyPBRRuleAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyPBRRuleAction")
	proto.RegisterType((*NetworkPolicyRuleAdvancedAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyRuleAdvancedAction")
	golang_proto.RegisterType((*NetworkPolicyRuleAdvancedAction)(nil), "ves.io.schema.network_policy_rule.NetworkPolicyRuleAdvancedAction")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy_rule.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy_rule.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy_rule.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy_rule.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy_rule.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy_rule.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy_rule.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy_rule.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/network_policy_rule/types.proto", fileDescriptor_8508d684cd4d0a5f)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/network_policy_rule/types.proto", fileDescriptor_8508d684cd4d0a5f)
}

var fileDescriptor_8508d684cd4d0a5f = []byte{
	// 950 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x97, 0xc1, 0x6f, 0x1b, 0x45,
	0x14, 0xc6, 0xf7, 0x65, 0xd7, 0x8e, 0x3d, 0x49, 0x63, 0x6b, 0x01, 0xc5, 0xb8, 0xed, 0xc6, 0x35,
	0x12, 0xb2, 0x2a, 0x67, 0xdd, 0xa6, 0x12, 0x88, 0x4a, 0x14, 0x65, 0x13, 0x94, 0x14, 0xdc, 0xd8,
	0x9a, 0x16, 0x2a, 0x10, 0x92, 0xb5, 0x5e, 0x8f, 0x9d, 0x25, 0x6b, 0xcf, 0x32, 0xbb, 0x76, 0x9a,
	0x43, 0xa5, 0x0a, 0x71, 0xe4, 0x80, 0x22, 0x71, 0xe9, 0x5f, 0x80, 0x38, 0xf5, 0x8c, 0x73, 0xc8,
	0x11, 0x71, 0xca, 0x31, 0xca, 0x05, 0x62, 0x5f, 0xca, 0x2d, 0xe2, 0xc8, 0x09, 0xed, 0xec, 0xda,
	0xcd, 0xae, 0x5b, 0x01, 0x51, 0x73, 0xcb, 0xed, 0xed, 0x7c, 0x6f, 0xbe, 0xf7, 0xc6, 0xfb, 0x7b,
	0xd6, 0x2c, 0x5a, 0xec, 0x11, 0x47, 0x35, 0x69, 0xc9, 0x31, 0x36, 0x49, 0x5b, 0x2f, 0x75, 0x88,
	0xbb, 0x4d, 0xd9, 0x56, 0xcd, 0xa6, 0x96, 0x69, 0xec, 0xd4, 0x58, 0xd7, 0x22, 0x25, 0x77, 0xc7,
	0x26, 0x8e, 0x6a, 0x33, 0xea, 0x52, 0xf9, 0x9a, 0x9f, 0xae, 0xfa, 0xe9, 0xea, 0x4b, 0xd2, 0xb3,
	0x8b, 0x2d, 0xd3, 0xdd, 0xec, 0xd6, 0x55, 0x83, 0xb6, 0x4b, 0x2d, 0xda, 0xa2, 0x25, 0xbe, 0xb3,
	0xde, 0x6d, 0xf2, 0x27, 0xfe, 0xc0, 0x23, 0xdf, 0x31, 0x3b, 0x3f, 0xd1, 0x40, 0x20, 0x5c, 0x0e,
	0x0b, 0xd4, 0x76, 0x4d, 0xda, 0x09, 0xfa, 0xc8, 0xbe, 0x1d, 0x16, 0x4f, 0xb5, 0x98, 0xbd, 0x12,
	0x96, 0x7a, 0xba, 0x65, 0x36, 0x74, 0x97, 0x04, 0x6a, 0x2e, 0xa2, 0x9a, 0x64, 0xbb, 0x16, 0xb6,
	0x5e, 0x98, 0xcc, 0x70, 0x4e, 0x17, 0xc8, 0x7f, 0x07, 0x28, 0xbb, 0xe1, 0x1f, 0xbc, 0xca, 0xcf,
	0x5d, 0xd5, 0x30, 0xee, 0x5a, 0x64, 0xd9, 0xf0, 0x6c, 0xe4, 0x26, 0x4a, 0x37, 0x29, 0xdb, 0xd6,
	0x59, 0xc3, 0xec, 0xb4, 0x6a, 0x86, 0xa5, 0x3b, 0x4e, 0x06, 0x72, 0x62, 0x61, 0x66, 0xe9, 0x8a,
	0x1a, 0xfe, 0xf5, 0x2a, 0xf5, 0xaf, 0x89, 0xe1, 0x62, 0xd2, 0x7c, 0xb0, 0x63, 0x13, 0xed, 0xea,
	0xcf, 0x8f, 0x27, 0x36, 0xfe, 0xf2, 0xe7, 0xbe, 0x18, 0xdb, 0x85, 0xa9, 0xb4, 0x88, 0x53, 0x2f,
	0xb4, 0x15, 0x4f, 0xca, 0x33, 0xb4, 0x10, 0xea, 0x82, 0xb7, 0xd0, 0xe8, 0xe9, 0x1d, 0x83, 0x34,
	0x82, 0x56, 0x2a, 0x28, 0xae, 0xf3, 0x28, 0x03, 0x39, 0x28, 0xcc, 0x2d, 0x15, 0xd5, 0x7f, 0x7d,
	0x7d, 0x6a, 0x99, 0xb6, 0xfc, 0xdd, 0x5a, 0xf2, 0xa8, 0x0f, 0xb1, 0x8d, 0x4a, 0xb9, 0xb2, 0x86,
	0x03, 0x9b, 0xfc, 0xf7, 0x71, 0x34, 0xb7, 0x66, 0xd1, 0xba, 0x6e, 0xdd, 0xb7, 0x89, 0xe1, 0xb5,
	0x2d, 0x7f, 0x15, 0xa9, 0x71, 0xfb, 0x3f, 0xd4, 0x98, 0xec, 0xdb, 0xaf, 0x98, 0x38, 0xea, 0x83,
	0xb4, 0xfa, 0xf1, 0xc6, 0x17, 0xa3, 0x82, 0xf2, 0x0d, 0x14, 0xb3, 0x29, 0x73, 0x9d, 0xcc, 0x54,
	0x4e, 0x2c, 0x24, 0xb5, 0xac, 0xf7, 0x83, 0xa0, 0x5d, 0x98, 0xce, 0xc7, 0x98, 0xf8, 0x0c, 0xc0,
	0x7b, 0x8c, 0xef, 0x82, 0x98, 0x7e, 0x02, 0xd8, 0x4f, 0x94, 0x3f, 0x42, 0x09, 0xfe, 0x9a, 0x0c,
	0x6a, 0x65, 0xc4, 0x1c, 0x14, 0x92, 0xda, 0x3b, 0x47, 0x7d, 0x10, 0x97, 0xcb, 0x65, 0x2f, 0x79,
	0x9e, 0xbd, 0x85, 0xbd, 0x18, 0x8b, 0x0f, 0x56, 0xaa, 0x58, 0xfc, 0x6c, 0xb5, 0x8a, 0xa5, 0xbb,
	0x2b, 0xf7, 0xaa, 0x78, 0xbc, 0x49, 0x7e, 0x1f, 0xc5, 0x6d, 0x46, 0x9a, 0xe6, 0xa3, 0x8c, 0x94,
	0x83, 0xc2, 0xcc, 0xd2, 0xd5, 0xc8, 0x81, 0xaa, 0x5c, 0x2c, 0x9b, 0x8e, 0xeb, 0x9d, 0x7f, 0x5d,
	0xc0, 0x41, 0xba, 0xfc, 0x39, 0x4a, 0xf9, 0x51, 0xcd, 0x21, 0x16, 0x31, 0x5c, 0xca, 0x32, 0x31,
	0xee, 0x90, 0x8b, 0x38, 0x94, 0xf5, 0x3a, 0xb1, 0xee, 0x07, 0x39, 0xfc, 0xdd, 0x27, 0x9f, 0xee,
	0x41, 0x0c, 0x89, 0x02, 0x88, 0xeb, 0x02, 0x9e, 0xf3, 0x5d, 0x46, 0x09, 0xf2, 0x1a, 0xba, 0x64,
	0xda, 0xb5, 0xb1, 0xb5, 0x9b, 0x99, 0xe6, 0xae, 0xd7, 0x22, 0xae, 0x77, 0xed, 0x6a, 0xb0, 0x6f,
	0x84, 0xd4, 0xba, 0x80, 0x67, 0xcc, 0x17, 0xab, 0x32, 0x46, 0x97, 0x2c, 0xaf, 0x74, 0xad, 0xad,
	0xbb, 0xc6, 0x26, 0x61, 0x99, 0x38, 0x37, 0x5a, 0x78, 0x59, 0x7b, 0xf7, 0xfc, 0x14, 0xde, 0xdd,
	0xec, 0xd3, 0x3d, 0x90, 0xd0, 0x14, 0x88, 0xcf, 0xf6, 0x00, 0xf0, 0xac, 0x75, 0x4a, 0x97, 0x09,
	0x42, 0x76, 0x9d, 0xd5, 0x02, 0x04, 0x12, 0xdc, 0xf0, 0xc3, 0xff, 0x8b, 0x40, 0x68, 0x80, 0xb4,
	0xe9, 0xc3, 0xc7, 0xf0, 0xbc, 0x0f, 0x80, 0x93, 0x76, 0x9d, 0x05, 0x24, 0x7f, 0x83, 0x52, 0x7a,
	0xc0, 0xf6, 0xa8, 0x16, 0xe2, 0xb5, 0xb4, 0x33, 0xe1, 0x16, 0x1a, 0x13, 0x4d, 0x3a, 0xf1, 0xaa,
	0xcd, 0xe9, 0xe1, 0xd5, 0xcb, 0x28, 0xc5, 0x48, 0x9b, 0xba, 0xa4, 0x46, 0x3a, 0x0d, 0x9b, 0x9a,
	0x1d, 0x57, 0x4e, 0xec, 0xf7, 0x41, 0x3a, 0xe8, 0x43, 0xf2, 0x13, 0x29, 0x91, 0x4c, 0xa3, 0xfc,
	0x40, 0x42, 0x73, 0x2b, 0x8c, 0xe8, 0x2e, 0x19, 0x8f, 0x03, 0x7e, 0x7d, 0xe3, 0x30, 0x1e, 0x82,
	0x37, 0x43, 0x43, 0x30, 0x02, 0x3d, 0x1b, 0x05, 0xfd, 0x75, 0x30, 0xfc, 0xe9, 0x99, 0x19, 0x3e,
	0x4f, 0x70, 0x57, 0xcf, 0x06, 0x6e, 0x04, 0xd5, 0xad, 0x73, 0x64, 0x28, 0x4a, 0xcf, 0xed, 0xdc,
	0x6f, 0x77, 0x22, 0xff, 0x94, 0x7f, 0xdd, 0x99, 0xbd, 0x59, 0xfc, 0xa0, 0x78, 0xab, 0xb8, 0x54,
	0x7c, 0xaf, 0x78, 0xf3, 0x86, 0xf6, 0xee, 0x24, 0x5f, 0x6f, 0x7c, 0xfb, 0x37, 0x44, 0x17, 0xf3,
	0x43, 0x09, 0xa5, 0x30, 0xb1, 0x2d, 0xdd, 0xb8, 0xa0, 0xec, 0x82, 0xb2, 0xf3, 0xa2, 0xec, 0x77,
	0x09, 0xcd, 0xac, 0x11, 0xf7, 0x82, 0xb0, 0x0b, 0xc2, 0xce, 0x87, 0xb0, 0xeb, 0x2a, 0x9a, 0x7f,
	0x05, 0x20, 0x72, 0x02, 0xf1, 0x5b, 0x5f, 0x5a, 0x90, 0x93, 0x28, 0xb6, 0x5c, 0x2e, 0x57, 0x1e,
	0xa6, 0xe1, 0xfa, 0x02, 0x4a, 0x8e, 0xef, 0xa2, 0xde, 0x3a, 0xbf, 0x89, 0xa6, 0x05, 0x79, 0x1a,
	0x89, 0x5e, 0x00, 0xda, 0x8f, 0x70, 0x70, 0xac, 0x08, 0x87, 0xc7, 0x8a, 0x70, 0x72, 0xac, 0xc0,
	0x93, 0x81, 0x02, 0x3f, 0x0d, 0x14, 0xf8, 0x75, 0xa0, 0xc0, 0xc1, 0x40, 0x81, 0xc3, 0x81, 0x02,
	0x7f, 0x0c, 0x14, 0x78, 0x3e, 0x50, 0x84, 0x93, 0x81, 0x02, 0x3f, 0x0c, 0x15, 0x61, 0x7f, 0xa8,
	0xc0, 0xc1, 0x50, 0x11, 0x0e, 0x87, 0x8a, 0xf0, 0xe5, 0xc3, 0x16, 0xb5, 0xb7, 0x5a, 0x6a, 0x8f,
	0x5a, 0x2e, 0x61, 0x4c, 0x57, 0xbb, 0x4e, 0x89, 0x07, 0x4d, 0xca, 0xda, 0x8b, 0x36, 0xa3, 0x3d,
	0xb3, 0x41, 0xd8, 0xe2, 0x48, 0x2e, 0xd9, 0xf5, 0x16, 0x2d, 0x91, 0x47, 0x6e, 0xf0, 0x59, 0xf0,
	0xea, 0xef, 0xa5, 0x7a, 0x9c, 0xe3, 0x7b, 0xeb, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x48, 0x33,
	0xf8, 0x38, 0x5b, 0x0d, 0x00, 0x00,
}

func (x NetworkPolicyRuleAction) String() string {
	s, ok := NetworkPolicyRuleAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LogAction) String() string {
	s, ok := LogAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NetworkPolicyPBRRuleAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyPBRRuleAction)
	if !ok {
		that2, ok := that.(NetworkPolicyPBRRuleAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ForwardingClass) != len(that1.ForwardingClass) {
		return false
	}
	for i := range this.ForwardingClass {
		if !this.ForwardingClass[i].Equal(that1.ForwardingClass[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkPolicyRuleAdvancedAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleAdvancedAction)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleAdvancedAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.PbrAction.Equal(that1.PbrAction) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Prefix)
	if !ok {
		that2, ok := that.(GlobalSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(GlobalSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *CreateSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Prefix)
	if !ok {
		that2, ok := that.(CreateSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *CreateSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(CreateSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Prefix)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.RemoteEndpoint == nil {
		if this.RemoteEndpoint != nil {
			return false
		}
	} else if this.RemoteEndpoint == nil {
		return false
	} else if !this.RemoteEndpoint.Equal(that1.RemoteEndpoint) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.AdvancedAction.Equal(that1.AdvancedAction) {
		return false
	}
	return true
}
func (this *GetSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Prefix)
	if !ok {
		that2, ok := that.(GetSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GetSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GetSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IpPrefixSet)
	if !ok {
		that2, ok := that.(GetSpecType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *NetworkPolicyPBRRuleAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_policy_rule.NetworkPolicyPBRRuleAction{")
	if this.ForwardingClass != nil {
		s = append(s, "ForwardingClass: "+fmt.Sprintf("%#v", this.ForwardingClass)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPolicyRuleAdvancedAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_policy_rule.NetworkPolicyRuleAdvancedAction{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_policy_rule.GlobalSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.PbrAction != nil {
		s = append(s, "PbrAction: "+fmt.Sprintf("%#v", this.PbrAction)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GlobalSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GlobalSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GlobalSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&network_policy_rule.CreateSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.CreateSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.CreateSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.CreateSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&network_policy_rule.ReplaceSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.ReplaceSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.ReplaceSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.ReplaceSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&network_policy_rule.GetSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.RemoteEndpoint != nil {
		s = append(s, "RemoteEndpoint: "+fmt.Sprintf("%#v", this.RemoteEndpoint)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.AdvancedAction != nil {
		s = append(s, "AdvancedAction: "+fmt.Sprintf("%#v", this.AdvancedAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GetSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GetSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GetSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy_rule.GetSpecType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NetworkPolicyPBRRuleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyPBRRuleAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyPBRRuleAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForwardingClass) > 0 {
		for iNdEx := len(m.ForwardingClass) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForwardingClass[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPolicyRuleAdvancedAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyRuleAdvancedAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleAdvancedAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvancedAction != nil {
		{
			size, err := m.AdvancedAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PbrAction != nil {
		{
			size, err := m.PbrAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RemoteEndpoint != nil {
		{
			size := m.RemoteEndpoint.Size()
			i -= size
			if _, err := m.RemoteEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PrefixSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixSelector != nil {
		{
			size, err := m.PrefixSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IpPrefixSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixSet != nil {
		{
			size, err := m.IpPrefixSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvancedAction != nil {
		{
			size, err := m.AdvancedAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.RemoteEndpoint != nil {
		{
			size := m.RemoteEndpoint.Size()
			i -= size
			if _, err := m.RemoteEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_PrefixSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixSelector != nil {
		{
			size, err := m.PrefixSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IpPrefixSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixSet != nil {
		{
			size, err := m.IpPrefixSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvancedAction != nil {
		{
			size, err := m.AdvancedAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.RemoteEndpoint != nil {
		{
			size := m.RemoteEndpoint.Size()
			i -= size
			if _, err := m.RemoteEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_PrefixSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixSelector != nil {
		{
			size, err := m.PrefixSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IpPrefixSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixSet != nil {
		{
			size, err := m.IpPrefixSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvancedAction != nil {
		{
			size, err := m.AdvancedAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.RemoteEndpoint != nil {
		{
			size := m.RemoteEndpoint.Size()
			i -= size
			if _, err := m.RemoteEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_PrefixSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixSelector != nil {
		{
			size, err := m.PrefixSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IpPrefixSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixSet != nil {
		{
			size, err := m.IpPrefixSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NetworkPolicyPBRRuleAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ForwardingClass) > 0 {
		for _, e := range m.ForwardingClass {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkPolicyRuleAdvancedAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PbrAction != nil {
		l = m.PbrAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PrefixSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IpPrefixSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_PrefixSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IpPrefixSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_PrefixSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IpPrefixSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteEndpoint != nil {
		n += m.RemoteEndpoint.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvancedAction != nil {
		l = m.AdvancedAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_PrefixSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IpPrefixSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NetworkPolicyPBRRuleAction) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForForwardingClass := "[]*ObjectRefType{"
	for _, f := range this.ForwardingClass {
		repeatedStringForForwardingClass += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForForwardingClass += "}"
	s := strings.Join([]string{`&NetworkPolicyPBRRuleAction{`,
		`ForwardingClass:` + repeatedStringForForwardingClass + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleAdvancedAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleAdvancedAction{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`PbrAction:` + strings.Replace(this.PbrAction.String(), "NetworkPolicyPBRRuleAction", "NetworkPolicyPBRRuleAction", 1) + `,`,
		`AdvancedAction:` + strings.Replace(this.AdvancedAction.String(), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "schema.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "schema.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`AdvancedAction:` + strings.Replace(this.AdvancedAction.String(), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "schema.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "schema.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`AdvancedAction:` + strings.Replace(this.AdvancedAction.String(), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "schema.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "schema.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`RemoteEndpoint:` + fmt.Sprintf("%v", this.RemoteEndpoint) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`AdvancedAction:` + strings.Replace(this.AdvancedAction.String(), "NetworkPolicyRuleAdvancedAction", "NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "schema.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "schema.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NetworkPolicyPBRRuleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyPBRRuleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyPBRRuleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingClass = append(m.ForwardingClass, &schema.ObjectRefType{})
			if err := m.ForwardingClass[len(m.ForwardingClass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicyRuleAdvancedAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyRuleAdvancedAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyRuleAdvancedAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= LogAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NetworkPolicyRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GlobalSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GlobalSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GlobalSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PbrAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PbrAction == nil {
				m.PbrAction = &NetworkPolicyPBRRuleAction{}
			}
			if err := m.PbrAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NetworkPolicyRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &CreateSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &CreateSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &CreateSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NetworkPolicyRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &ReplaceSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &ReplaceSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &ReplaceSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NetworkPolicyRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GetSpecType_Prefix{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GetSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RemoteEndpoint = &GetSpecType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedAction == nil {
				m.AdvancedAction = &NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvancedAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
