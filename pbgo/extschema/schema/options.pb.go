// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/options.proto

package schema

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReferenceType
//
// x-displayName: "Reference Type"
// MessageOptions related messages
type ReferenceType int32

const (
	// x-displayName "displayname"
	// This is the reference as defined in schema and stored in db
	FORWARD_REF ReferenceType = 0
	// x-displayName "displayname"
	// This is a runtime maintained mirror side of Forward Reference
	BACK_REF ReferenceType = 1
)

var ReferenceType_name = map[int32]string{
	0: "FORWARD_REF",
	1: "BACK_REF",
}

var ReferenceType_value = map[string]int32{
	"FORWARD_REF": 0,
	"BACK_REF":    1,
}

func (ReferenceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{0}
}

// KeyType
//
// x-displayName "keytype"
// Type of keys on an Object
type KeyType int32

const (
	// x-displayName "displayname"
	// Primary key is the default
	PRIMARY_KEY KeyType = 0
	// x-displayName "displayname"
	// Non unique secondary index
	SECONDARY_KEY KeyType = 1
	// x-displayName "displayname"
	// Unique secondary index
	SECONDARY_KEY_UNIQUE KeyType = 2
)

var KeyType_name = map[int32]string{
	0: "PRIMARY_KEY",
	1: "SECONDARY_KEY",
	2: "SECONDARY_KEY_UNIQUE",
}

var KeyType_value = map[string]int32{
	"PRIMARY_KEY":          0,
	"SECONDARY_KEY":        1,
	"SECONDARY_KEY_UNIQUE": 2,
}

func (KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{1}
}

// MetricType
//
// x-displayName "displayname"
// Types of metrics
type MetricType int32

const (
	// x-displayName "displayname"
	// Invalid metric type
	UNSPECIFIED MetricType = 0
	// x-displayName "displayname"
	// Gauge metric type
	GAUGE MetricType = 1
	// x-displayName "displayname"
	// Counter metric type
	COUNTER MetricType = 2
	// x-displayName "displayname"
	// Histogram metric type
	HISTOGRAM MetricType = 3
	// x-displayName "displayname"
	// Summary metric type
	SUMMARY MetricType = 4
)

var MetricType_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GAUGE",
	2: "COUNTER",
	3: "HISTOGRAM",
	4: "SUMMARY",
}

var MetricType_value = map[string]int32{
	"UNSPECIFIED": 0,
	"GAUGE":       1,
	"COUNTER":     2,
	"HISTOGRAM":   3,
	"SUMMARY":     4,
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{2}
}

// ServiceType
//
// x-displayName "displayname"
// Type of protobuf service on configuration or operational Object
type ServiceType int32

const (
	// x-displayName "displayname"
	// CUSTOM is DEPRECATED by CUSTOM_PUBLIC
	CUSTOM ServiceType = 0
	// x-displayName "displayname"
	// AUTO_CRUD is external private API for CRUD operations
	AUTO_CRUD ServiceType = 1
	// x-displayName "displayname"
	// AUTO_CRUD_PUBLIC is external public API for CRUD operations
	AUTO_CRUD_PUBLIC ServiceType = 2
	// x-displayName "displayname"
	// CUSTOM_PUBLIC is external public API for custom operations
	CUSTOM_PUBLIC ServiceType = 3
	// x-displayName "displayname"
	// CUSTOM_PRIVATE is external private API for custom operations
	CUSTOM_PRIVATE ServiceType = 4
)

var ServiceType_name = map[int32]string{
	0: "CUSTOM",
	1: "AUTO_CRUD",
	2: "AUTO_CRUD_PUBLIC",
	3: "CUSTOM_PUBLIC",
	4: "CUSTOM_PRIVATE",
}

var ServiceType_value = map[string]int32{
	"CUSTOM":           0,
	"AUTO_CRUD":        1,
	"AUTO_CRUD_PUBLIC": 2,
	"CUSTOM_PUBLIC":    3,
	"CUSTOM_PRIVATE":   4,
}

func (ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{3}
}

// Via
//
// x-displayName: "Via"
// This message option is used with On to specify the spans of a path
// leading from an object type (say virtual_network) to its dependent
// object types (say interface, route)
type Via struct {
	// type
	//
	// x-displayName: "Type"
	// dependency is on the remote object type
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// field_path
	//
	// x-displayName: "Field Path"
	// based on the specified field_path
	FieldPath string `protobuf:"bytes,2,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// ref_type
	//
	// x-displayName: "Reference Type"
	// whether the traversal is forward (reference field is defined in this
	// Object's definition) or reverse (reference field is defined in the
	// remote Object's definition)
	RefType ReferenceType `protobuf:"varint,3,opt,name=ref_type,json=refType,proto3,enum=ves.io.schema.ReferenceType" json:"ref_type,omitempty"`
	// gen_field_path
	//
	// x-displayName: "Generate dependencies using field path"
	// generate dependency evaluation code using the specified field_path
	GenFieldPath bool `protobuf:"varint,4,opt,name=gen_field_path,json=genFieldPath,proto3" json:"gen_field_path,omitempty"`
}

func (m *Via) Reset()      { *m = Via{} }
func (*Via) ProtoMessage() {}
func (*Via) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{0}
}
func (m *Via) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Via) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Via) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Via.Merge(m, src)
}
func (m *Via) XXX_Size() int {
	return m.Size()
}
func (m *Via) XXX_DiscardUnknown() {
	xxx_messageInfo_Via.DiscardUnknown(m)
}

var xxx_messageInfo_Via proto.InternalMessageInfo

func (m *Via) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Via) GetFieldPath() string {
	if m != nil {
		return m.FieldPath
	}
	return ""
}

func (m *Via) GetRefType() ReferenceType {
	if m != nil {
		return m.RefType
	}
	return FORWARD_REF
}

func (m *Via) GetGenFieldPath() bool {
	if m != nil {
		return m.GenFieldPath
	}
	return false
}

// On
//
// x-displayName: "On"
// This message option is used in Dependencies to indicate which other
// object types an object type is dependent upon for correct functioning.
type On struct {
	// type
	//
	// x-displayName: "Type"
	// This is the dependent object type which when updated we need to
	// react upon
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// via
	//
	// x-displayName: "Via"
	// This is the set of spans to walk to reach the dependent object type
	// specified by type
	Via []*Via `protobuf:"bytes,2,rep,name=via,proto3" json:"via,omitempty"`
}

func (m *On) Reset()      { *m = On{} }
func (*On) ProtoMessage() {}
func (*On) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{1}
}
func (m *On) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *On) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *On) XXX_Merge(src proto.Message) {
	xxx_messageInfo_On.Merge(m, src)
}
func (m *On) XXX_Size() int {
	return m.Size()
}
func (m *On) XXX_DiscardUnknown() {
	xxx_messageInfo_On.DiscardUnknown(m)
}

var xxx_messageInfo_On proto.InternalMessageInfo

func (m *On) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *On) GetVia() []*Via {
	if m != nil {
		return m.Via
	}
	return nil
}

// Dependencies
//
// x-displayName: "Dependencies"
// This message option is used to indicate an object-type is dependent
// (i.e. needs to be re-evaluated) based on updates to another object-type.
// For example a virtual_network object definition may use this option to
// indicate that notification has to be issued when an interface object
// undergoes change. This is specific to the daemon implementation and
// should be used on the 'Object' message definition at the service's repo
// schema directory.
type Dependencies struct {
	// on
	//
	// x-displayName: "On"
	// This encodes the set of dependent object types and paths leading to them
	On []*On `protobuf:"bytes,1,rep,name=on,proto3" json:"on,omitempty"`
	// for
	//
	// x-displayName: "for"
	// The object type for which the dependencies are specified
	For string `protobuf:"bytes,2,opt,name=for,proto3" json:"for,omitempty"`
}

func (m *Dependencies) Reset()      { *m = Dependencies{} }
func (*Dependencies) ProtoMessage() {}
func (*Dependencies) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{2}
}
func (m *Dependencies) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dependencies) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Dependencies) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dependencies.Merge(m, src)
}
func (m *Dependencies) XXX_Size() int {
	return m.Size()
}
func (m *Dependencies) XXX_DiscardUnknown() {
	xxx_messageInfo_Dependencies.DiscardUnknown(m)
}

var xxx_messageInfo_Dependencies proto.InternalMessageInfo

func (m *Dependencies) GetOn() []*On {
	if m != nil {
		return m.On
	}
	return nil
}

func (m *Dependencies) GetFor() string {
	if m != nil {
		return m.For
	}
	return ""
}

// DependenciesSet
//
// x-displayName: "DependenciesSet"
// This message option is used to indicate the dependencies for multiple
// object types
type DependenciesSet struct {
	// dependencies
	//
	// x-displayName: "Dependencies"
	// List of dependencies per object type
	Dependencies []*Dependencies `protobuf:"bytes,1,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
}

func (m *DependenciesSet) Reset()      { *m = DependenciesSet{} }
func (*DependenciesSet) ProtoMessage() {}
func (*DependenciesSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{3}
}
func (m *DependenciesSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DependenciesSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DependenciesSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DependenciesSet.Merge(m, src)
}
func (m *DependenciesSet) XXX_Size() int {
	return m.Size()
}
func (m *DependenciesSet) XXX_DiscardUnknown() {
	xxx_messageInfo_DependenciesSet.DiscardUnknown(m)
}

var xxx_messageInfo_DependenciesSet proto.InternalMessageInfo

func (m *DependenciesSet) GetDependencies() []*Dependencies {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

// Key
//
// x-displayName "key"
// Shape of key
type Key struct {
	// Field path
	//
	// x-displayName "Field path"
	// Field Path
	FieldPath string `protobuf:"bytes,1,opt,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	// Key
	//
	// x-displayName "Key"
	// Key
	Type KeyType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.KeyType" json:"type,omitempty"`
}

func (m *Key) Reset()      { *m = Key{} }
func (*Key) ProtoMessage() {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{4}
}
func (m *Key) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return m.Size()
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

func (m *Key) GetFieldPath() string {
	if m != nil {
		return m.FieldPath
	}
	return ""
}

func (m *Key) GetType() KeyType {
	if m != nil {
		return m.Type
	}
	return PRIMARY_KEY
}

// Keys
//
// x-displayName "keys"
// Shape of keys
type Keys struct {
	// list of Keys
	//
	// x-displayName "Keys"
	// Keys
	Keys []*Key `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *Keys) Reset()      { *m = Keys{} }
func (*Keys) ProtoMessage() {}
func (*Keys) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{5}
}
func (m *Keys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Keys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Keys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Keys.Merge(m, src)
}
func (m *Keys) XXX_Size() int {
	return m.Size()
}
func (m *Keys) XXX_DiscardUnknown() {
	xxx_messageInfo_Keys.DiscardUnknown(m)
}

var xxx_messageInfo_Keys proto.InternalMessageInfo

func (m *Keys) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
type MetricDef struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// name of the metric
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Human readable description of the metric
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Describes what type of metric this is.
	Type MetricType `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.MetricType" json:"type,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Label configuration to use
	Labels []string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Buckets to use for histogram
	Buckets []float64 `protobuf:"fixed64,5,rep,packed,name=buckets,proto3" json:"buckets,omitempty"`
}

func (m *MetricDef) Reset()      { *m = MetricDef{} }
func (*MetricDef) ProtoMessage() {}
func (*MetricDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_8562c0a0fb65343f, []int{6}
}
func (m *MetricDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricDef.Merge(m, src)
}
func (m *MetricDef) XXX_Size() int {
	return m.Size()
}
func (m *MetricDef) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricDef.DiscardUnknown(m)
}

var xxx_messageInfo_MetricDef proto.InternalMessageInfo

func (m *MetricDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDef) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return UNSPECIFIED
}

func (m *MetricDef) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *MetricDef) GetBuckets() []float64 {
	if m != nil {
		return m.Buckets
	}
	return nil
}

var E_Dependencies = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*Dependencies)(nil),
	Field:         1000,
	Name:          "ves.io.schema.dependencies",
	Tag:           "bytes,1000,opt,name=dependencies",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToMsg = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1001,
	Name:          "ves.io.schema.maps_to_msg",
	Tag:           "bytes,1001,opt,name=maps_to_msg",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToSvc = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1003,
	Name:          "ves.io.schema.maps_to_svc",
	Tag:           "bytes,1003,opt,name=maps_to_svc",
	Filename:      "ves.io/schema/options.proto",
}

var E_Keys = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*Keys)(nil),
	Field:         1002,
	Name:          "ves.io.schema.keys",
	Tag:           "bytes,1002,opt,name=keys",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsMsgConfidential = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1004,
	Name:          "ves.io.schema.is_msg_confidential",
	Tag:           "varint,1004,opt,name=is_msg_confidential",
	Filename:      "ves.io/schema/options.proto",
}

var E_GetSpecNotCreateSpecSuperset = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1005,
	Name:          "ves.io.schema.get_spec_not_create_spec_superset",
	Tag:           "varint,1005,opt,name=get_spec_not_create_spec_superset",
	Filename:      "ves.io/schema/options.proto",
}

var E_DisplayOrder = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1006,
	Name:          "ves.io.schema.display_order",
	Tag:           "bytes,1006,opt,name=display_order",
	Filename:      "ves.io/schema/options.proto",
}

var E_GeneratePrivateApiMethods = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1007,
	Name:          "ves.io.schema.generate_private_api_methods",
	Tag:           "bytes,1007,opt,name=generate_private_api_methods",
	Filename:      "ves.io/schema/options.proto",
}

var E_InNamespaceTypes = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1008,
	Name:          "ves.io.schema.in_namespace_types",
	Tag:           "bytes,1008,opt,name=in_namespace_types",
	Filename:      "ves.io/schema/options.proto",
}

var E_NoUnsafeDelete = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1009,
	Name:          "ves.io.schema.no_unsafe_delete",
	Tag:           "varint,1009,opt,name=no_unsafe_delete",
	Filename:      "ves.io/schema/options.proto",
}

var E_AllowColonInName = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1010,
	Name:          "ves.io.schema.allow_colon_in_name",
	Tag:           "varint,1010,opt,name=allow_colon_in_name",
	Filename:      "ves.io/schema/options.proto",
}

var E_InDevelopmentCrud = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1011,
	Name:          "ves.io.schema.in_development_crud",
	Tag:           "bytes,1011,opt,name=in_development_crud",
	Filename:      "ves.io/schema/options.proto",
}

var E_DependenciesSet = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*DependenciesSet)(nil),
	Field:         1012,
	Name:          "ves.io.schema.dependencies_set",
	Tag:           "bytes,1012,opt,name=dependencies_set",
	Filename:      "ves.io/schema/options.proto",
}

var E_GeneratePublicCrud = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FileOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1000,
	Name:          "ves.io.schema.generate_public_crud",
	Tag:           "varint,1000,opt,name=generate_public_crud",
	Filename:      "ves.io/schema/options.proto",
}

var E_GeneratePublicApiMethods = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FileOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1001,
	Name:          "ves.io.schema.generate_public_api_methods",
	Tag:           "bytes,1001,opt,name=generate_public_api_methods",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsPkey = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2000,
	Name:          "ves.io.schema.is_pkey",
	Tag:           "varint,2000,opt,name=is_pkey",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsSkeyUniq = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2001,
	Name:          "ves.io.schema.is_skey_uniq",
	Tag:           "varint,2001,opt,name=is_skey_uniq",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsSkey = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2002,
	Name:          "ves.io.schema.is_skey",
	Tag:           "varint,2002,opt,name=is_skey",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToField = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2003,
	Name:          "ves.io.schema.maps_to_field",
	Tag:           "bytes,2003,opt,name=maps_to_field",
	Filename:      "ves.io/schema/options.proto",
}

var E_Metric = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*MetricDef)(nil),
	Field:         2004,
	Name:          "ves.io.schema.metric",
	Tag:           "bytes,2004,opt,name=metric",
	Filename:      "ves.io/schema/options.proto",
}

var E_RefTo = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2005,
	Name:          "ves.io.schema.ref_to",
	Tag:           "bytes,2005,opt,name=ref_to",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsRefSecondary = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2006,
	Name:          "ves.io.schema.is_ref_secondary",
	Tag:           "varint,2006,opt,name=is_ref_secondary",
	Filename:      "ves.io/schema/options.proto",
}

var E_LabelSelectorObjectKind = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2007,
	Name:          "ves.io.schema.label_selector_object_kind",
	Tag:           "bytes,2007,opt,name=label_selector_object_kind",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsObject = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2008,
	Name:          "ves.io.schema.is_object",
	Tag:           "varint,2008,opt,name=is_object",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsFieldConfidential = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2009,
	Name:          "ves.io.schema.is_field_confidential",
	Tag:           "varint,2009,opt,name=is_field_confidential",
	Filename:      "ves.io/schema/options.proto",
}

var E_GenerateSetter = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2010,
	Name:          "ves.io.schema.generate_setter",
	Tag:           "varint,2010,opt,name=generate_setter",
	Filename:      "ves.io/schema/options.proto",
}

var E_Internal = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2011,
	Name:          "ves.io.schema.internal",
	Tag:           "varint,2011,opt,name=internal",
	Filename:      "ves.io/schema/options.proto",
}

var E_Deprecated = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         2012,
	Name:          "ves.io.schema.deprecated",
	Tag:           "bytes,2012,opt,name=deprecated",
	Filename:      "ves.io/schema/options.proto",
}

var E_ServiceType = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*ServiceType)(nil),
	Field:         3000,
	Name:          "ves.io.schema.service_type",
	Tag:           "varint,3000,opt,name=service_type,enum=ves.io.schema.ServiceType",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsSdro = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         3001,
	Name:          "ves.io.schema.is_sdro",
	Tag:           "varint,3001,opt,name=is_sdro",
	Filename:      "ves.io/schema/options.proto",
}

var E_ObjectType = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         3002,
	Name:          "ves.io.schema.object_type",
	Tag:           "bytes,3002,opt,name=object_type",
	Filename:      "ves.io/schema/options.proto",
}

var E_HasStatus = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         3003,
	Name:          "ves.io.schema.has_status",
	Tag:           "varint,3003,opt,name=has_status",
	Filename:      "ves.io/schema/options.proto",
}

var E_ObjectStatusType = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         3004,
	Name:          "ves.io.schema.object_status_type",
	Tag:           "bytes,3004,opt,name=object_status_type",
	Filename:      "ves.io/schema/options.proto",
}

var E_DeprecatedService = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         3006,
	Name:          "ves.io.schema.deprecated_service",
	Tag:           "bytes,3006,opt,name=deprecated_service",
	Filename:      "ves.io/schema/options.proto",
}

var E_InDevelopmentService = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.ServiceOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         3007,
	Name:          "ves.io.schema.in_development_service",
	Tag:           "bytes,3007,opt,name=in_development_service",
	Filename:      "ves.io/schema/options.proto",
}

var E_MapsToOneofField = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.OneofOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         4000,
	Name:          "ves.io.schema.maps_to_oneof_field",
	Tag:           "bytes,4000,opt,name=maps_to_oneof_field",
	Filename:      "ves.io/schema/options.proto",
}

var E_InternalEnum = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         2000,
	Name:          "ves.io.schema.internal_enum",
	Tag:           "varint,2000,opt,name=internal_enum",
	Filename:      "ves.io/schema/options.proto",
}

var E_IsImmutable = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MethodOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         5001,
	Name:          "ves.io.schema.is_immutable",
	Tag:           "varint,5001,opt,name=is_immutable",
	Filename:      "ves.io/schema/options.proto",
}

var E_DeprecatedMethod = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MethodOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         5003,
	Name:          "ves.io.schema.deprecated_method",
	Tag:           "bytes,5003,opt,name=deprecated_method",
	Filename:      "ves.io/schema/options.proto",
}

var E_InDevelopmentMethod = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MethodOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         5004,
	Name:          "ves.io.schema.in_development_method",
	Tag:           "bytes,5004,opt,name=in_development_method",
	Filename:      "ves.io/schema/options.proto",
}

func init() {
	proto.RegisterEnum("ves.io.schema.ReferenceType", ReferenceType_name, ReferenceType_value)
	proto.RegisterEnum("ves.io.schema.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("ves.io.schema.MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("ves.io.schema.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterType((*Via)(nil), "ves.io.schema.Via")
	proto.RegisterType((*On)(nil), "ves.io.schema.On")
	proto.RegisterType((*Dependencies)(nil), "ves.io.schema.Dependencies")
	proto.RegisterType((*DependenciesSet)(nil), "ves.io.schema.DependenciesSet")
	proto.RegisterType((*Key)(nil), "ves.io.schema.Key")
	proto.RegisterType((*Keys)(nil), "ves.io.schema.Keys")
	proto.RegisterType((*MetricDef)(nil), "ves.io.schema.MetricDef")
	proto.RegisterExtension(E_Dependencies)
	proto.RegisterExtension(E_MapsToMsg)
	proto.RegisterExtension(E_MapsToSvc)
	proto.RegisterExtension(E_Keys)
	proto.RegisterExtension(E_IsMsgConfidential)
	proto.RegisterExtension(E_GetSpecNotCreateSpecSuperset)
	proto.RegisterExtension(E_DisplayOrder)
	proto.RegisterExtension(E_GeneratePrivateApiMethods)
	proto.RegisterExtension(E_InNamespaceTypes)
	proto.RegisterExtension(E_NoUnsafeDelete)
	proto.RegisterExtension(E_AllowColonInName)
	proto.RegisterExtension(E_InDevelopmentCrud)
	proto.RegisterExtension(E_DependenciesSet)
	proto.RegisterExtension(E_GeneratePublicCrud)
	proto.RegisterExtension(E_GeneratePublicApiMethods)
	proto.RegisterExtension(E_IsPkey)
	proto.RegisterExtension(E_IsSkeyUniq)
	proto.RegisterExtension(E_IsSkey)
	proto.RegisterExtension(E_MapsToField)
	proto.RegisterExtension(E_Metric)
	proto.RegisterExtension(E_RefTo)
	proto.RegisterExtension(E_IsRefSecondary)
	proto.RegisterExtension(E_LabelSelectorObjectKind)
	proto.RegisterExtension(E_IsObject)
	proto.RegisterExtension(E_IsFieldConfidential)
	proto.RegisterExtension(E_GenerateSetter)
	proto.RegisterExtension(E_Internal)
	proto.RegisterExtension(E_Deprecated)
	proto.RegisterExtension(E_ServiceType)
	proto.RegisterExtension(E_IsSdro)
	proto.RegisterExtension(E_ObjectType)
	proto.RegisterExtension(E_HasStatus)
	proto.RegisterExtension(E_ObjectStatusType)
	proto.RegisterExtension(E_DeprecatedService)
	proto.RegisterExtension(E_InDevelopmentService)
	proto.RegisterExtension(E_MapsToOneofField)
	proto.RegisterExtension(E_InternalEnum)
	proto.RegisterExtension(E_IsImmutable)
	proto.RegisterExtension(E_DeprecatedMethod)
	proto.RegisterExtension(E_InDevelopmentMethod)
}

func init() { proto.RegisterFile("ves.io/schema/options.proto", fileDescriptor_8562c0a0fb65343f) }

var fileDescriptor_8562c0a0fb65343f = []byte{
	// 1690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x98, 0x49, 0x6f, 0xe3, 0xc8,
	0x15, 0xc7, 0x45, 0xc9, 0xed, 0xe5, 0xc9, 0x0b, 0x4d, 0xf7, 0x74, 0x6b, 0xba, 0x3b, 0x1a, 0xb5,
	0x31, 0xc8, 0x18, 0x06, 0x5a, 0x06, 0x26, 0x08, 0x06, 0x61, 0x80, 0x99, 0x91, 0x25, 0xd9, 0xa3,
	0x78, 0x64, 0x69, 0x28, 0xcb, 0xc1, 0x24, 0x01, 0x08, 0x8a, 0x7c, 0xa2, 0x2b, 0xa2, 0xaa, 0x38,
	0x2c, 0x4a, 0x89, 0x0e, 0x01, 0x72, 0x0d, 0x92, 0x43, 0x6e, 0xb9, 0x06, 0x39, 0xe5, 0x23, 0x64,
	0x43, 0x72, 0xcd, 0xb1, 0xb3, 0x77, 0x96, 0x43, 0xda, 0x7d, 0x99, 0xec, 0x9d, 0xe5, 0x03, 0x04,
	0xac, 0x22, 0xad, 0xa5, 0x9d, 0xa1, 0x73, 0x32, 0x6b, 0xf9, 0xff, 0xea, 0x5f, 0x4f, 0xaf, 0x5e,
	0x15, 0x0c, 0xf7, 0xc7, 0xc8, 0xcb, 0x84, 0x1d, 0x70, 0xfb, 0x02, 0x87, 0xd6, 0x01, 0xf3, 0x43,
	0xc2, 0x28, 0x2f, 0xfb, 0x01, 0x0b, 0x99, 0xb6, 0x21, 0x07, 0xcb, 0x72, 0xf0, 0xde, 0x23, 0x97,
	0x84, 0x17, 0xa3, 0x5e, 0xd9, 0x66, 0xc3, 0x03, 0x97, 0xb9, 0xec, 0x40, 0xcc, 0xea, 0x8d, 0xfa,
	0xa2, 0x25, 0x1a, 0xe2, 0x4b, 0xaa, 0xef, 0x95, 0x5c, 0xc6, 0x5c, 0x0f, 0xa7, 0xb3, 0x1c, 0xe4,
	0x76, 0x40, 0xfc, 0x90, 0x05, 0x72, 0xc6, 0xee, 0xb7, 0x14, 0xc8, 0x9d, 0x13, 0x4b, 0xd3, 0x60,
	0x29, 0x9c, 0xf8, 0x58, 0x50, 0x4a, 0xca, 0xde, 0x9a, 0x21, 0xbe, 0xb5, 0x8f, 0x01, 0xf4, 0x09,
	0x7a, 0x8e, 0xe9, 0x5b, 0xe1, 0x45, 0x21, 0x2b, 0x46, 0xd6, 0x44, 0x4f, 0xdb, 0x0a, 0x2f, 0xb4,
	0x37, 0x60, 0x35, 0xc0, 0xbe, 0x29, 0x64, 0xb9, 0x92, 0xb2, 0xb7, 0xf9, 0xfa, 0x83, 0xf2, 0x9c,
	0xdb, 0xb2, 0x81, 0x7d, 0x0c, 0x90, 0xda, 0x78, 0x36, 0xf1, 0xd1, 0x58, 0x09, 0xb0, 0x1f, 0x7d,
	0x68, 0xaf, 0xc2, 0xa6, 0x8b, 0xd4, 0x9c, 0x61, 0x2f, 0x95, 0x94, 0xbd, 0x55, 0x63, 0xdd, 0x45,
	0x7a, 0x94, 0xe0, 0x77, 0xdf, 0x84, 0x6c, 0x8b, 0x5e, 0xeb, 0xeb, 0x55, 0xc8, 0x8d, 0x89, 0x55,
	0xc8, 0x96, 0x72, 0x7b, 0xf9, 0xd7, 0xb5, 0x85, 0x35, 0xcf, 0x89, 0x65, 0x44, 0xc3, 0xbb, 0x55,
	0x58, 0xaf, 0xa1, 0x8f, 0xd4, 0x41, 0x6a, 0x13, 0xe4, 0xda, 0x43, 0xc8, 0x32, 0x5a, 0x50, 0x84,
	0x68, 0x7b, 0x41, 0xd4, 0xa2, 0x46, 0x96, 0x51, 0x4d, 0x85, 0x5c, 0x9f, 0x05, 0xf1, 0x4e, 0xa3,
	0xcf, 0x5d, 0x03, 0xb6, 0x66, 0x21, 0x1d, 0x0c, 0xb5, 0xb7, 0x60, 0xdd, 0x99, 0xe9, 0x8a, 0x89,
	0xf7, 0x17, 0x88, 0xb3, 0x2a, 0x63, 0x4e, 0xb0, 0xdb, 0x86, 0xdc, 0x09, 0x4e, 0x16, 0xa2, 0xab,
	0x2c, 0x46, 0x77, 0x3f, 0xde, 0x78, 0x56, 0x44, 0xf6, 0xce, 0x02, 0xfe, 0x04, 0x27, 0x22, 0xa6,
	0x62, 0xce, 0x6e, 0x19, 0x96, 0x4e, 0x70, 0xc2, 0xb5, 0x8f, 0xc3, 0xd2, 0x00, 0x27, 0x89, 0x25,
	0xed, 0x45, 0x8d, 0x21, 0xc6, 0x77, 0xbf, 0xa3, 0xc0, 0x5a, 0x13, 0xc3, 0x80, 0xd8, 0x35, 0xec,
	0x47, 0x21, 0xa6, 0xd6, 0xf0, 0x2a, 0xc4, 0xd1, 0xb7, 0x56, 0x82, 0x7c, 0x92, 0x2a, 0x84, 0xd1,
	0x38, 0x22, 0xb3, 0x5d, 0xda, 0xa3, 0xd8, 0x9f, 0xfc, 0xe5, 0x5f, 0x5e, 0x58, 0x4b, 0xd2, 0xa7,
	0x16, 0xb5, 0x3b, 0xb0, 0xec, 0x59, 0x3d, 0xf4, 0x78, 0x61, 0xa9, 0x94, 0xdb, 0x5b, 0x33, 0xe2,
	0x96, 0x56, 0x80, 0x95, 0xde, 0xc8, 0x1e, 0x60, 0xc8, 0x0b, 0xb7, 0x4a, 0xb9, 0x3d, 0xc5, 0x48,
	0x9a, 0xfb, 0x65, 0xd8, 0x98, 0xcb, 0x1f, 0x6d, 0x0b, 0xf2, 0x47, 0x2d, 0xe3, 0xb3, 0x15, 0xa3,
	0x66, 0x1a, 0xf5, 0x23, 0x35, 0xa3, 0xad, 0xc3, 0xea, 0x61, 0xa5, 0x7a, 0x22, 0x5a, 0xca, 0xfe,
	0x31, 0xac, 0xc4, 0x51, 0x89, 0x66, 0xb6, 0x8d, 0x46, 0xb3, 0x62, 0xbc, 0x6f, 0x9e, 0xd4, 0xdf,
	0x57, 0x33, 0xda, 0x36, 0x6c, 0x74, 0xea, 0xd5, 0xd6, 0x69, 0x2d, 0xe9, 0x52, 0xb4, 0x02, 0xdc,
	0x9e, 0xeb, 0x32, 0xbb, 0xa7, 0x8d, 0xf7, 0xba, 0x75, 0x35, 0xbb, 0xff, 0x1e, 0xc0, 0xd4, 0x7e,
	0xc4, 0xea, 0x9e, 0x76, 0xda, 0xf5, 0x6a, 0xe3, 0xa8, 0x51, 0xaf, 0xa9, 0x19, 0x6d, 0x0d, 0x6e,
	0x1d, 0x57, 0xba, 0xc7, 0x75, 0x55, 0xd1, 0xf2, 0xb0, 0x52, 0x6d, 0x75, 0x4f, 0xcf, 0xea, 0x86,
	0x9a, 0xd5, 0x36, 0x60, 0xed, 0x9d, 0x46, 0xe7, 0xac, 0x75, 0x6c, 0x54, 0x9a, 0x6a, 0x2e, 0x1a,
	0xeb, 0x74, 0x9b, 0x91, 0x07, 0x75, 0x69, 0x1f, 0x21, 0xdf, 0xc1, 0x60, 0x4c, 0xe2, 0x9d, 0x00,
	0x2c, 0x57, 0xbb, 0x9d, 0xb3, 0x56, 0x53, 0xcd, 0x44, 0xb2, 0x4a, 0xf7, 0xac, 0x65, 0x56, 0x8d,
	0x6e, 0x4d, 0x55, 0xb4, 0xdb, 0xa0, 0x5e, 0x35, 0xcd, 0x76, 0xf7, 0xf0, 0xdd, 0x46, 0x55, 0xcd,
	0x46, 0xfe, 0xa5, 0x20, 0xe9, 0xca, 0x69, 0x1a, 0x6c, 0x26, 0x5d, 0x46, 0xe3, 0xbc, 0x72, 0x56,
	0x57, 0x97, 0x74, 0x6b, 0x3e, 0x35, 0xb5, 0x57, 0xca, 0xf2, 0xfc, 0x97, 0x93, 0xf3, 0x5f, 0x6e,
	0x22, 0xe7, 0x96, 0x8b, 0x2d, 0x59, 0x63, 0x0a, 0x1f, 0xae, 0x94, 0x94, 0xff, 0x2b, 0x79, 0xf5,
	0xb7, 0x21, 0x3f, 0xb4, 0x7c, 0x6e, 0x86, 0xcc, 0x1c, 0x72, 0x37, 0x7d, 0x85, 0x3f, 0xad, 0xc8,
	0xc4, 0x8e, 0x44, 0x67, 0xac, 0xc9, 0xdd, 0x59, 0x02, 0x1f, 0xdb, 0xe9, 0x84, 0xbf, 0xcc, 0x11,
	0x3a, 0x63, 0x5b, 0x6f, 0xc8, 0x34, 0x4f, 0x97, 0xfe, 0x59, 0x6e, 0x6f, 0xe7, 0xc5, 0x83, 0xc0,
	0xe5, 0x49, 0xd0, 0xdb, 0xb0, 0x43, 0x78, 0xb4, 0x13, 0xd3, 0x66, 0xb4, 0x4f, 0x1c, 0xa4, 0x21,
	0xb1, 0xbc, 0x74, 0xf2, 0x5f, 0x57, 0x44, 0xc5, 0xda, 0x26, 0xbc, 0xc9, 0xdd, 0xea, 0x8c, 0x54,
	0x27, 0xf0, 0xd0, 0xc5, 0xd0, 0xe4, 0x3e, 0xda, 0x26, 0x65, 0xa1, 0x69, 0x07, 0x68, 0x85, 0x28,
	0xdb, 0x7c, 0xe4, 0x63, 0xc0, 0x31, 0x4c, 0xe7, 0xff, 0x4d, 0xf2, 0x1f, 0xb8, 0x18, 0x76, 0x7c,
	0xb4, 0x4f, 0x59, 0x58, 0x15, 0x9c, 0xa8, 0xd1, 0x89, 0x29, 0x7a, 0x1d, 0x36, 0x1c, 0xc2, 0x7d,
	0xcf, 0x9a, 0x98, 0x2c, 0x70, 0x30, 0x48, 0xc7, 0xfe, 0x5d, 0xc6, 0x72, 0x3d, 0x96, 0xb5, 0x22,
	0x95, 0x6e, 0xc1, 0x03, 0x17, 0x29, 0x06, 0x91, 0x4d, 0x3f, 0x20, 0xe3, 0xe8, 0xaf, 0xe5, 0x13,
	0x73, 0x88, 0xe1, 0x05, 0x73, 0x6e, 0x10, 0xe6, 0x7f, 0x48, 0xea, 0xcb, 0x09, 0xa5, 0x2d, 0x21,
	0x15, 0x9f, 0x34, 0x25, 0x42, 0x3f, 0x05, 0x8d, 0x50, 0x33, 0xaa, 0x2c, 0xdc, 0xb7, 0x6c, 0x14,
	0x77, 0xc6, 0x0d, 0xc0, 0xcf, 0x25, 0x58, 0x25, 0xf4, 0x34, 0x91, 0x46, 0xe7, 0x87, 0xeb, 0x9f,
	0x01, 0x95, 0x32, 0x73, 0x44, 0xb9, 0xd5, 0x47, 0xd3, 0x41, 0x0f, 0x43, 0x4c, 0xa7, 0xfd, 0x53,
	0xc6, 0x74, 0x93, 0xb2, 0xae, 0x10, 0xd6, 0x84, 0x4e, 0x6f, 0xc1, 0x8e, 0xe5, 0x79, 0xec, 0x4b,
	0xa6, 0xcd, 0x3c, 0x46, 0xcd, 0xd8, 0x67, 0x3a, 0xee, 0x5f, 0x12, 0xa7, 0x0a, 0x71, 0x35, 0xd2,
	0x36, 0x84, 0x4d, 0x91, 0x53, 0xd4, 0x74, 0x70, 0x8c, 0x1e, 0xf3, 0x87, 0x48, 0xa3, 0x1c, 0x18,
	0x39, 0xe9, 0xc0, 0x7f, 0xcb, 0xdd, 0x6e, 0x13, 0x5a, 0x9b, 0x6a, 0xab, 0xc1, 0xc8, 0xd1, 0x07,
	0xa0, 0xce, 0x1e, 0x42, 0xf3, 0x46, 0x29, 0xf4, 0x1f, 0x99, 0xfc, 0xc5, 0x8f, 0x38, 0xdb, 0x1d,
	0x0c, 0x8d, 0x2d, 0x67, 0xbe, 0x43, 0x6f, 0xc1, 0xed, 0x69, 0x3a, 0x8c, 0x7a, 0x1e, 0xb1, 0xa5,
	0xff, 0x07, 0x2f, 0x2c, 0x78, 0x44, 0xbc, 0xf9, 0x4a, 0xb2, 0x6a, 0x68, 0x57, 0x39, 0x20, 0x94,
	0xc2, 0xfd, 0x17, 0xe0, 0xfe, 0x22, 0x70, 0x36, 0xbd, 0x3e, 0x9a, 0x1b, 0xd7, 0x8f, 0xc2, 0x3c,
	0x77, 0x26, 0xb5, 0xde, 0x80, 0x15, 0xc2, 0x4d, 0x7f, 0x10, 0xdd, 0xa8, 0xd7, 0x90, 0xd0, 0x73,
	0x12, 0xd4, 0xe3, 0x2d, 0x61, 0x71, 0x99, 0xf0, 0xf6, 0x00, 0x27, 0xfa, 0xdb, 0xb0, 0x4e, 0xb8,
	0xc9, 0x07, 0x38, 0x31, 0x47, 0x94, 0x7c, 0x90, 0xa6, 0xfe, 0x99, 0x54, 0x03, 0xe1, 0x9d, 0x01,
	0x4e, 0xba, 0x94, 0x7c, 0x10, 0x2f, 0xcd, 0x6f, 0xb0, 0xf4, 0xcf, 0xaf, 0x96, 0x8e, 0xc4, 0xfa,
	0x21, 0x6c, 0x24, 0x25, 0x50, 0x5c, 0xf8, 0x69, 0xf2, 0x5f, 0x6c, 0xc9, 0xfb, 0x57, 0x96, 0x40,
	0x31, 0xa4, 0xb7, 0x61, 0x79, 0x28, 0x6e, 0xa9, 0x34, 0xf1, 0x2f, 0xb7, 0x44, 0x1e, 0x14, 0xae,
	0xbd, 0xa1, 0x6b, 0xd8, 0x37, 0x62, 0x8e, 0xfe, 0x49, 0x58, 0x16, 0xef, 0x39, 0x96, 0x46, 0xfc,
	0x95, 0xb4, 0x73, 0x2b, 0x7a, 0xcf, 0x31, 0xfd, 0x1d, 0x50, 0x09, 0x37, 0x23, 0x25, 0x47, 0x9b,
	0x51, 0xc7, 0x0a, 0x52, 0xc3, 0xf1, 0x6b, 0x19, 0x8e, 0x4d, 0xc2, 0x0d, 0xec, 0x77, 0x12, 0x95,
	0xfe, 0x79, 0xb8, 0x27, 0x5e, 0x05, 0x26, 0x47, 0x0f, 0xed, 0x90, 0x05, 0x26, 0xeb, 0x7d, 0x11,
	0xed, 0xd0, 0x1c, 0x10, 0x9a, 0x1a, 0xa3, 0xdf, 0x48, 0x53, 0x77, 0x05, 0xa1, 0x13, 0x03, 0x5a,
	0x42, 0x7f, 0x42, 0xa8, 0xa3, 0x7f, 0x1a, 0xd6, 0x08, 0x8f, 0x81, 0x69, 0xac, 0x27, 0xd2, 0xdf,
	0x2a, 0xe1, 0x12, 0xa0, 0x1b, 0xf0, 0x12, 0xe1, 0xf1, 0x83, 0x75, 0xee, 0xa2, 0x48, 0x01, 0xfd,
	0x56, 0x82, 0x76, 0x08, 0x17, 0xdd, 0x73, 0x17, 0xc5, 0x31, 0x6c, 0x5d, 0x1d, 0x0b, 0x8e, 0x61,
	0x88, 0x41, 0x1a, 0xed, 0x77, 0x71, 0xd8, 0x12, 0x59, 0x47, 0xa8, 0x74, 0x1d, 0x56, 0x09, 0x0d,
	0x31, 0xa0, 0xe9, 0x7e, 0x7e, 0x9f, 0x6c, 0x2c, 0x9e, 0xaf, 0xbf, 0x09, 0xe0, 0xa0, 0x1f, 0xa0,
	0x6d, 0x85, 0x98, 0x1a, 0xe2, 0x3f, 0xc8, 0x10, 0xcf, 0x28, 0x74, 0x13, 0xd6, 0xb9, 0x7c, 0xd8,
	0x88, 0x9a, 0x7e, 0x4d, 0x55, 0x8a, 0xdf, 0x3d, 0x09, 0xe3, 0x7b, 0x77, 0xc5, 0x7b, 0xf1, 0xde,
	0x42, 0x36, 0xce, 0xbc, 0x8e, 0x8c, 0x3c, 0x9f, 0x36, 0xf4, 0x4f, 0xc9, 0x33, 0xe6, 0x04, 0x2c,
	0x9d, 0xfd, 0xfd, 0xbb, 0x57, 0xa7, 0xcc, 0x09, 0x98, 0x5e, 0x81, 0x7c, 0x9c, 0x3f, 0x37, 0xb3,
	0xf6, 0x83, 0xbb, 0x72, 0x7b, 0x52, 0x24, 0x56, 0x7f, 0x0b, 0xe0, 0xc2, 0xe2, 0x26, 0x0f, 0xad,
	0x70, 0xc4, 0xd3, 0x09, 0x3f, 0x94, 0x06, 0xd6, 0x2e, 0x2c, 0xde, 0x11, 0x92, 0xe8, 0xe2, 0x8b,
	0x3d, 0x48, 0xc6, 0x0d, 0xad, 0xfc, 0x48, 0x5a, 0x51, 0xa5, 0x56, 0xb2, 0x84, 0xa1, 0x16, 0x68,
	0xd3, 0xe8, 0x9b, 0x71, 0xa0, 0xd2, 0x79, 0x3f, 0x96, 0xbc, 0xed, 0xa9, 0x36, 0x9e, 0xa0, 0x9f,
	0xc3, 0x9d, 0x85, 0xcb, 0xea, 0xc6, 0xd0, 0x9f, 0x48, 0xe8, 0xed, 0xb9, 0xfb, 0x2a, 0xe1, 0x36,
	0x61, 0x27, 0x29, 0x71, 0x8c, 0x22, 0xeb, 0xff, 0xcf, 0x42, 0xd7, 0x8a, 0x46, 0x13, 0xe4, 0xb7,
	0x5f, 0x91, 0xfb, 0x96, 0x85, 0x4e, 0x0c, 0xc9, 0x6a, 0x77, 0x0c, 0x1b, 0x49, 0xce, 0x9a, 0x48,
	0x47, 0x43, 0xed, 0xe1, 0x0b, 0xa0, 0x3a, 0x1d, 0x0d, 0xcf, 0x2d, 0x6f, 0x84, 0x0b, 0xf5, 0x7e,
	0x3d, 0x11, 0x46, 0x13, 0xf4, 0x43, 0x51, 0xf5, 0xc9, 0x70, 0x38, 0x0a, 0xad, 0x9e, 0x87, 0x5a,
	0xf1, 0x9a, 0x6b, 0x34, 0xba, 0x58, 0x12, 0xc8, 0xd7, 0x5e, 0x13, 0x90, 0x3c, 0xe1, 0x8d, 0x44,
	0xa3, 0xbf, 0x0b, 0x33, 0x81, 0x8c, 0xef, 0xb1, 0x54, 0xd0, 0xd7, 0x5f, 0x93, 0x5b, 0x9b, 0x2a,
	0xe5, 0xb8, 0xde, 0x81, 0x97, 0x16, 0x7e, 0x81, 0x1b, 0x12, 0xbf, 0x21, 0x89, 0x3b, 0x73, 0xf1,
	0x97, 0x53, 0x0e, 0xbf, 0xf2, 0xf8, 0x69, 0x31, 0xf3, 0xe4, 0x69, 0x31, 0xf3, 0xfc, 0x69, 0x51,
	0xf9, 0xea, 0x65, 0x51, 0xf9, 0xee, 0x65, 0x51, 0xf9, 0xe9, 0x65, 0x51, 0x79, 0x7c, 0x59, 0x54,
	0x9e, 0x5c, 0x16, 0x95, 0x3f, 0x5e, 0x16, 0x95, 0x0f, 0x2f, 0x8b, 0x99, 0xe7, 0x97, 0x45, 0xe5,
	0x9b, 0xcf, 0x8a, 0x99, 0xc7, 0xcf, 0x8a, 0x99, 0x27, 0xcf, 0x8a, 0x99, 0xcf, 0x55, 0x5d, 0xe6,
	0x0f, 0xdc, 0xf2, 0x98, 0x79, 0x21, 0x06, 0x81, 0x55, 0x1e, 0xf1, 0x03, 0xf1, 0xd1, 0x67, 0xc1,
	0xf0, 0x91, 0x1f, 0xb0, 0x31, 0x71, 0x30, 0x78, 0x94, 0x0c, 0x1f, 0xf8, 0x3d, 0x97, 0x1d, 0xe0,
	0x97, 0xc3, 0xf8, 0x9f, 0x17, 0xf2, 0x4f, 0x6f, 0x59, 0x58, 0xfe, 0xc4, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x8a, 0xa0, 0x66, 0xd4, 0xdb, 0x10, 0x00, 0x00,
}

func (x ReferenceType) String() string {
	s, ok := ReferenceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KeyType) String() string {
	s, ok := KeyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricType) String() string {
	s, ok := MetricType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ServiceType) String() string {
	s, ok := ServiceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Via) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Via)
	if !ok {
		that2, ok := that.(Via)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.FieldPath != that1.FieldPath {
		return false
	}
	if this.RefType != that1.RefType {
		return false
	}
	if this.GenFieldPath != that1.GenFieldPath {
		return false
	}
	return true
}
func (this *On) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*On)
	if !ok {
		that2, ok := that.(On)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Via) != len(that1.Via) {
		return false
	}
	for i := range this.Via {
		if !this.Via[i].Equal(that1.Via[i]) {
			return false
		}
	}
	return true
}
func (this *Dependencies) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Dependencies)
	if !ok {
		that2, ok := that.(Dependencies)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.On) != len(that1.On) {
		return false
	}
	for i := range this.On {
		if !this.On[i].Equal(that1.On[i]) {
			return false
		}
	}
	if this.For != that1.For {
		return false
	}
	return true
}
func (this *DependenciesSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DependenciesSet)
	if !ok {
		that2, ok := that.(DependenciesSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Dependencies) != len(that1.Dependencies) {
		return false
	}
	for i := range this.Dependencies {
		if !this.Dependencies[i].Equal(that1.Dependencies[i]) {
			return false
		}
	}
	return true
}
func (this *Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Key)
	if !ok {
		that2, ok := that.(Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FieldPath != that1.FieldPath {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Keys) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Keys)
	if !ok {
		that2, ok := that.(Keys)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !this.Keys[i].Equal(that1.Keys[i]) {
			return false
		}
	}
	return true
}
func (this *MetricDef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricDef)
	if !ok {
		that2, ok := that.(MetricDef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Buckets) != len(that1.Buckets) {
		return false
	}
	for i := range this.Buckets {
		if this.Buckets[i] != that1.Buckets[i] {
			return false
		}
	}
	return true
}
func (this *Via) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.Via{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "FieldPath: "+fmt.Sprintf("%#v", this.FieldPath)+",\n")
	s = append(s, "RefType: "+fmt.Sprintf("%#v", this.RefType)+",\n")
	s = append(s, "GenFieldPath: "+fmt.Sprintf("%#v", this.GenFieldPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *On) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.On{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Via != nil {
		s = append(s, "Via: "+fmt.Sprintf("%#v", this.Via)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Dependencies) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Dependencies{")
	if this.On != nil {
		s = append(s, "On: "+fmt.Sprintf("%#v", this.On)+",\n")
	}
	s = append(s, "For: "+fmt.Sprintf("%#v", this.For)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DependenciesSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DependenciesSet{")
	if this.Dependencies != nil {
		s = append(s, "Dependencies: "+fmt.Sprintf("%#v", this.Dependencies)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Key{")
	s = append(s, "FieldPath: "+fmt.Sprintf("%#v", this.FieldPath)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Keys) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.Keys{")
	if this.Keys != nil {
		s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricDef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.MetricDef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	s = append(s, "Buckets: "+fmt.Sprintf("%#v", this.Buckets)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringOptions(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Via) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Via) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Via) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GenFieldPath {
		i--
		if m.GenFieldPath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RefType != 0 {
		i = encodeVarintOptions(dAtA, i, uint64(m.RefType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FieldPath) > 0 {
		i -= len(m.FieldPath)
		copy(dAtA[i:], m.FieldPath)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.FieldPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *On) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *On) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *On) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Via) > 0 {
		for iNdEx := len(m.Via) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Via[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Dependencies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dependencies) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dependencies) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.For) > 0 {
		i -= len(m.For)
		copy(dAtA[i:], m.For)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.For)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.On) > 0 {
		for iNdEx := len(m.On) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.On[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DependenciesSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DependenciesSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DependenciesSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dependencies) > 0 {
		for iNdEx := len(m.Dependencies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dependencies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintOptions(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FieldPath) > 0 {
		i -= len(m.FieldPath)
		copy(dAtA[i:], m.FieldPath)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.FieldPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Keys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Keys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOptions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.Buckets[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
		}
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Buckets)*8))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Labels[iNdEx])
			copy(dAtA[i:], m.Labels[iNdEx])
			i = encodeVarintOptions(dAtA, i, uint64(len(m.Labels[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Type != 0 {
		i = encodeVarintOptions(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOptions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOptions(dAtA []byte, offset int, v uint64) int {
	offset -= sovOptions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Via) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.RefType != 0 {
		n += 1 + sovOptions(uint64(m.RefType))
	}
	if m.GenFieldPath {
		n += 2
	}
	return n
}

func (m *On) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if len(m.Via) > 0 {
		for _, e := range m.Via {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	return n
}

func (m *Dependencies) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, e := range m.On {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	l = len(m.For)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	return n
}

func (m *DependenciesSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dependencies) > 0 {
		for _, e := range m.Dependencies {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	return n
}

func (m *Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOptions(uint64(m.Type))
	}
	return n
}

func (m *Keys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	return n
}

func (m *MetricDef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOptions(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOptions(uint64(m.Type))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovOptions(uint64(l))
		}
	}
	if len(m.Buckets) > 0 {
		n += 1 + sovOptions(uint64(len(m.Buckets)*8)) + len(m.Buckets)*8
	}
	return n
}

func sovOptions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOptions(x uint64) (n int) {
	return sovOptions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Via) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Via{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`FieldPath:` + fmt.Sprintf("%v", this.FieldPath) + `,`,
		`RefType:` + fmt.Sprintf("%v", this.RefType) + `,`,
		`GenFieldPath:` + fmt.Sprintf("%v", this.GenFieldPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *On) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVia := "[]*Via{"
	for _, f := range this.Via {
		repeatedStringForVia += strings.Replace(f.String(), "Via", "Via", 1) + ","
	}
	repeatedStringForVia += "}"
	s := strings.Join([]string{`&On{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Via:` + repeatedStringForVia + `,`,
		`}`,
	}, "")
	return s
}
func (this *Dependencies) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOn := "[]*On{"
	for _, f := range this.On {
		repeatedStringForOn += strings.Replace(f.String(), "On", "On", 1) + ","
	}
	repeatedStringForOn += "}"
	s := strings.Join([]string{`&Dependencies{`,
		`On:` + repeatedStringForOn + `,`,
		`For:` + fmt.Sprintf("%v", this.For) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DependenciesSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDependencies := "[]*Dependencies{"
	for _, f := range this.Dependencies {
		repeatedStringForDependencies += strings.Replace(f.String(), "Dependencies", "Dependencies", 1) + ","
	}
	repeatedStringForDependencies += "}"
	s := strings.Join([]string{`&DependenciesSet{`,
		`Dependencies:` + repeatedStringForDependencies + `,`,
		`}`,
	}, "")
	return s
}
func (this *Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Key{`,
		`FieldPath:` + fmt.Sprintf("%v", this.FieldPath) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Keys) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForKeys := "[]*Key{"
	for _, f := range this.Keys {
		repeatedStringForKeys += strings.Replace(f.String(), "Key", "Key", 1) + ","
	}
	repeatedStringForKeys += "}"
	s := strings.Join([]string{`&Keys{`,
		`Keys:` + repeatedStringForKeys + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricDef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricDef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Labels:` + fmt.Sprintf("%v", this.Labels) + `,`,
		`Buckets:` + fmt.Sprintf("%v", this.Buckets) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOptions(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Via) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Via: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Via: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			m.RefType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefType |= ReferenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenFieldPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GenFieldPath = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *On) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: On: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: On: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Via", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Via = append(m.Via, &Via{})
			if err := m.Via[len(m.Via)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dependencies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dependencies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dependencies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field On", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.On = append(m.On, &On{})
			if err := m.On[len(m.On)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field For", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.For = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DependenciesSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DependenciesSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DependenciesSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, &Dependencies{})
			if err := m.Dependencies[len(m.Dependencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &Key{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Buckets = append(m.Buckets, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOptions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOptions
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOptions
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Buckets) == 0 {
					m.Buckets = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Buckets = append(m.Buckets, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOptions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOptions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOptions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOptions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOptions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOptions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOptions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOptions = fmt.Errorf("proto: unexpected end of group")
)
