//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package scim

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *Filter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Filter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Filter) DeepCopy() *Filter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Filter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Filter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Filter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FilterValidator().Validate(ctx, m, opts...)
}

type ValidateFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFilter) SupportedValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewBoolValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for supported")
	}

	return validatorFn, nil
}

func (v *ValidateFilter) MaxResultsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint64ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for maxResults")
	}

	return validatorFn, nil
}

func (v *ValidateFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Filter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Filter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["maxResults"]; exists {

		vOpts := append(opts, db.WithValidateField("maxResults"))
		if err := fv(ctx, m.GetMaxResults(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["supported"]; exists {

		vOpts := append(opts, db.WithValidateField("supported"))
		if err := fv(ctx, m.GetSupported(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFilterValidator = func() *ValidateFilter {
	v := &ValidateFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSupported := v.SupportedValidationRuleHandler
	rulesSupported := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSupported(rulesSupported)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Filter.supported: %s", err)
		panic(errMsg)
	}
	v.FldValidators["supported"] = vFn

	vrhMaxResults := v.MaxResultsValidationRuleHandler
	rulesMaxResults := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMaxResults(rulesMaxResults)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Filter.maxResults: %s", err)
		panic(errMsg)
	}
	v.FldValidators["maxResults"] = vFn

	return v
}()

func FilterValidator() db.Validator {
	return DefaultFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *FilterRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FilterRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FilterRequest) DeepCopy() *FilterRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FilterRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FilterRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FilterRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FilterRequestValidator().Validate(ctx, m, opts...)
}

type ValidateFilterRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFilterRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FilterRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FilterRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filter"]; exists {

		vOpts := append(opts, db.WithValidateField("filter"))
		if err := fv(ctx, m.GetFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page"]; exists {

		vOpts := append(opts, db.WithValidateField("page"))
		if err := fv(ctx, m.GetPage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFilterRequestValidator = func() *ValidateFilterRequest {
	v := &ValidateFilterRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FilterRequestValidator() db.Validator {
	return DefaultFilterRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *IdRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IdRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IdRequest) DeepCopy() *IdRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IdRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IdRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IdRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IdRequestValidator().Validate(ctx, m, opts...)
}

type ValidateIdRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIdRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateIdRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IdRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IdRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIdRequestValidator = func() *ValidateIdRequest {
	v := &ValidateIdRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IdRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	return v
}()

func IdRequestValidator() db.Validator {
	return DefaultIdRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *Meta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Meta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Meta) DeepCopy() *Meta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Meta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Meta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Meta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetaValidator().Validate(ctx, m, opts...)
}

type ValidateMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMeta) ResourceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for resourceType")
	}

	return validatorFn, nil
}

func (v *ValidateMeta) CreatedValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for created")
	}

	return validatorFn, nil
}

func (v *ValidateMeta) LastModifiedValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for lastModified")
	}

	return validatorFn, nil
}

func (v *ValidateMeta) LocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for location")
	}

	return validatorFn, nil
}

func (v *ValidateMeta) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}

	return validatorFn, nil
}

func (v *ValidateMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Meta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Meta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["created"]; exists {

		vOpts := append(opts, db.WithValidateField("created"))
		if err := fv(ctx, m.GetCreated(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lastModified"]; exists {

		vOpts := append(opts, db.WithValidateField("lastModified"))
		if err := fv(ctx, m.GetLastModified(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["location"]; exists {

		vOpts := append(opts, db.WithValidateField("location"))
		if err := fv(ctx, m.GetLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resourceType"]; exists {

		vOpts := append(opts, db.WithValidateField("resourceType"))
		if err := fv(ctx, m.GetResourceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetaValidator = func() *ValidateMeta {
	v := &ValidateMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResourceType := v.ResourceTypeValidationRuleHandler
	rulesResourceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhResourceType(rulesResourceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Meta.resourceType: %s", err)
		panic(errMsg)
	}
	v.FldValidators["resourceType"] = vFn

	vrhCreated := v.CreatedValidationRuleHandler
	rulesCreated := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCreated(rulesCreated)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Meta.created: %s", err)
		panic(errMsg)
	}
	v.FldValidators["created"] = vFn

	vrhLastModified := v.LastModifiedValidationRuleHandler
	rulesLastModified := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLastModified(rulesLastModified)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Meta.lastModified: %s", err)
		panic(errMsg)
	}
	v.FldValidators["lastModified"] = vFn

	vrhLocation := v.LocationValidationRuleHandler
	rulesLocation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLocation(rulesLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Meta.location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["location"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Meta.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	return v
}()

func MetaValidator() db.Validator {
	return DefaultMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *PatchOperation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PatchOperation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PatchOperation) DeepCopy() *PatchOperation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PatchOperation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PatchOperation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PatchOperation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PatchOperationValidator().Validate(ctx, m, opts...)
}

type ValidatePatchOperation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePatchOperation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PatchOperation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PatchOperation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPatchOperationValidator = func() *ValidatePatchOperation {
	v := &ValidatePatchOperation{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PatchOperationValidator() db.Validator {
	return DefaultPatchOperationValidator
}

// augmented methods on protoc/std generated struct

func (m *ResourceMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResourceMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResourceMeta) DeepCopy() *ResourceMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResourceMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResourceMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResourceMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResourceMetaValidator().Validate(ctx, m, opts...)
}

type ValidateResourceMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResourceMeta) ResourceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for resourceType")
	}

	return validatorFn, nil
}

func (v *ValidateResourceMeta) LocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for location")
	}

	return validatorFn, nil
}

func (v *ValidateResourceMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResourceMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResourceMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["location"]; exists {

		vOpts := append(opts, db.WithValidateField("location"))
		if err := fv(ctx, m.GetLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resourceType"]; exists {

		vOpts := append(opts, db.WithValidateField("resourceType"))
		if err := fv(ctx, m.GetResourceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResourceMetaValidator = func() *ValidateResourceMeta {
	v := &ValidateResourceMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResourceType := v.ResourceTypeValidationRuleHandler
	rulesResourceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhResourceType(rulesResourceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResourceMeta.resourceType: %s", err)
		panic(errMsg)
	}
	v.FldValidators["resourceType"] = vFn

	vrhLocation := v.LocationValidationRuleHandler
	rulesLocation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLocation(rulesLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResourceMeta.location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["location"] = vFn

	return v
}()

func ResourceMetaValidator() db.Validator {
	return DefaultResourceMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *Support) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Support) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Support) DeepCopy() *Support {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Support{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Support) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Support) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SupportValidator().Validate(ctx, m, opts...)
}

type ValidateSupport struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSupport) SupportedValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewBoolValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for supported")
	}

	return validatorFn, nil
}

func (v *ValidateSupport) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Support)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Support got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["supported"]; exists {

		vOpts := append(opts, db.WithValidateField("supported"))
		if err := fv(ctx, m.GetSupported(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSupportValidator = func() *ValidateSupport {
	v := &ValidateSupport{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSupported := v.SupportedValidationRuleHandler
	rulesSupported := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSupported(rulesSupported)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Support.supported: %s", err)
		panic(errMsg)
	}
	v.FldValidators["supported"] = vFn

	return v
}()

func SupportValidator() db.Validator {
	return DefaultSupportValidator
}
