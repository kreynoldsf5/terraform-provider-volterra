// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/scim/user_types.proto

package scim

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	user "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/user"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Name
//
// x-displayName: "Name"
// Name is the name of user.
type Name struct {
	// formatted
	//
	// x-displayName: "formatted"
	// x-example: "R Downey Jr"
	// Formatted name is detailed name of person.
	Formatted string `protobuf:"bytes,1,opt,name=formatted,proto3" json:"formatted,omitempty"`
	// familyName
	//
	// x-displayName: "familyName"
	// x-example: "Downey"
	// Family name.
	FamilyName string `protobuf:"bytes,2,opt,name=familyName,proto3" json:"familyName,omitempty"`
	// givenName
	//
	// x-displayName: "givenName"
	// x-example: "Robert J Downey Jr"
	// Given name of the person.
	GivenName string `protobuf:"bytes,3,opt,name=givenName,proto3" json:"givenName,omitempty"`
	// middleName
	//
	// x-displayName: "middleName"
	// x-example: "K"
	// Middle name of the person.
	MiddleName string `protobuf:"bytes,4,opt,name=middleName,proto3" json:"middleName,omitempty"`
	// honorificPrefix
	//
	// x-displayName: "honorificPrefix"
	// x-example: "Mr"
	// Prefix for the name. Mr Ms. etc.
	HonorificPrefix string `protobuf:"bytes,5,opt,name=honorificPrefix,proto3" json:"honorificPrefix,omitempty"`
	// honorificSuffix
	//
	// x-displayName: "honorificSuffix"
	// x-example: "IV"
	// Suffix for the name like Jr Sr I II III etc.
	HonorificSuffix string `protobuf:"bytes,6,opt,name=honorificSuffix,proto3" json:"honorificSuffix,omitempty"`
}

func (m *Name) Reset()      { *m = Name{} }
func (*Name) ProtoMessage() {}
func (*Name) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{0}
}
func (m *Name) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Name) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Name) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Name.Merge(m, src)
}
func (m *Name) XXX_Size() int {
	return m.Size()
}
func (m *Name) XXX_DiscardUnknown() {
	xxx_messageInfo_Name.DiscardUnknown(m)
}

var xxx_messageInfo_Name proto.InternalMessageInfo

func (m *Name) GetFormatted() string {
	if m != nil {
		return m.Formatted
	}
	return ""
}

func (m *Name) GetFamilyName() string {
	if m != nil {
		return m.FamilyName
	}
	return ""
}

func (m *Name) GetGivenName() string {
	if m != nil {
		return m.GivenName
	}
	return ""
}

func (m *Name) GetMiddleName() string {
	if m != nil {
		return m.MiddleName
	}
	return ""
}

func (m *Name) GetHonorificPrefix() string {
	if m != nil {
		return m.HonorificPrefix
	}
	return ""
}

func (m *Name) GetHonorificSuffix() string {
	if m != nil {
		return m.HonorificSuffix
	}
	return ""
}

// Email
//
// x-displayName: "Email"
// Email for user can be primary or secondary
type Email struct {
	// value
	//
	// x-displayName: "value"
	// x-example: "newEmail@domain.com"
	// value.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// type
	//
	// x-displayName: "type"
	// x-example: "work"
	// type of email describing whether it is work or personal.
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// primary
	//
	// x-displayName: "primary"
	// x-example: "true"
	// primary boolean describing whether it is primary or not.
	Primary bool `protobuf:"varint,3,opt,name=primary,proto3" json:"primary,omitempty"`
}

func (m *Email) Reset()      { *m = Email{} }
func (*Email) ProtoMessage() {}
func (*Email) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{1}
}
func (m *Email) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Email) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Email) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Email.Merge(m, src)
}
func (m *Email) XXX_Size() int {
	return m.Size()
}
func (m *Email) XXX_DiscardUnknown() {
	xxx_messageInfo_Email.DiscardUnknown(m)
}

var xxx_messageInfo_Email proto.InternalMessageInfo

func (m *Email) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Email) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Email) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

// UserGroup
//
// x-displayName: "UserGroup"
// UserGroup.
type UserGroup struct {
	// display
	//
	// x-displayName: "display"
	// x-example: "Group-1"
	// display for the user group name.
	Display string `protobuf:"bytes,1,opt,name=display,proto3" json:"display,omitempty"`
	// id
	//
	// x-displayName: "id"
	// x-example: "1234-2345-123456"
	// Id of the group to which user belongs.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *UserGroup) Reset()      { *m = UserGroup{} }
func (*UserGroup) ProtoMessage() {}
func (*UserGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{2}
}
func (m *UserGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserGroup.Merge(m, src)
}
func (m *UserGroup) XXX_Size() int {
	return m.Size()
}
func (m *UserGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_UserGroup.DiscardUnknown(m)
}

var xxx_messageInfo_UserGroup proto.InternalMessageInfo

func (m *UserGroup) GetDisplay() string {
	if m != nil {
		return m.Display
	}
	return ""
}

func (m *UserGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// CreateUserRequest
//
// x-displayName: "CreateUserRequest"
// CreateUserRequest is the request for creating a user.
type CreateUserRequest struct {
	// schemas
	//
	// x-displayName: "schemas"
	// x-example: "urn:ietf:params:scim:schemas:core:2.0:User"
	// schemas represent the schema from scim spec to be used for creating the user.
	Schemas []string `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// externalId
	//
	// x-displayName: "externalId"
	// x-example: "rod_123"
	// externalId refers to the id for user represented in the external system like azure etc.
	ExternalId string `protobuf:"bytes,2,opt,name=externalId,proto3" json:"externalId,omitempty"`
	// userName
	//
	// x-displayName: "userName"
	// x-example: "rod_123"
	// userName refers to the unique userName for this user. Can be emailId or username used in yahoo gmail etc.
	UserName string `protobuf:"bytes,3,opt,name=userName,proto3" json:"userName,omitempty"`
	// name
	//
	// x-displayName: "name"
	// x-example: "Rodney Robilliard"
	// name of user.
	Name *Name `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// displayName
	//
	// x-displayName: "displayName"
	// x-example: "Rod Rob"
	// displayName refers to the name to be displayed for the user. default is name.
	DisplayName string `protobuf:"bytes,5,opt,name=displayName,proto3" json:"displayName,omitempty"`
	// userType
	//
	// x-displayName: "userType"
	// x-example: "Contractor"
	// userType represents the type of user can be permanent employee or contractor etc.
	UserType user.UserType `protobuf:"varint,6,opt,name=userType,proto3,enum=ves.io.schema.user.UserType" json:"userType,omitempty"`
	// active
	//
	// x-displayName: "active"
	// x-example: "true/false"
	// active is boolean representing if user is active or not.
	Active bool `protobuf:"varint,7,opt,name=active,proto3" json:"active,omitempty"`
	// emails
	//
	// x-displayName: "emails"
	// x-example: "sam@test.com"
	// emails can be list of emails to be used by user work, personal etc.
	Emails []*Email `protobuf:"bytes,8,rep,name=emails,proto3" json:"emails,omitempty"`
	// groups
	//
	// x-displayName: "groups"
	// x-example: "groupid"
	// groups to which user belongs to.
	Groups []*UserGroup `protobuf:"bytes,9,rep,name=groups,proto3" json:"groups,omitempty"`
	// roles
	//
	// x-displayName: "roles"
	// x-required
	// x-example: "roles"
	// roles defined for the user.
	Roles []string `protobuf:"bytes,10,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *CreateUserRequest) Reset()      { *m = CreateUserRequest{} }
func (*CreateUserRequest) ProtoMessage() {}
func (*CreateUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{3}
}
func (m *CreateUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserRequest.Merge(m, src)
}
func (m *CreateUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserRequest proto.InternalMessageInfo

func (m *CreateUserRequest) GetSchemas() []string {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *CreateUserRequest) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *CreateUserRequest) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *CreateUserRequest) GetName() *Name {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *CreateUserRequest) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *CreateUserRequest) GetUserType() user.UserType {
	if m != nil {
		return m.UserType
	}
	return user.USER
}

func (m *CreateUserRequest) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *CreateUserRequest) GetEmails() []*Email {
	if m != nil {
		return m.Emails
	}
	return nil
}

func (m *CreateUserRequest) GetGroups() []*UserGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *CreateUserRequest) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// UserOperation
//
// x-displayName: "Operation"
// UserOperation is the patch operation where user can be  updated replaced or remove or delete.
// supported op types are add, remove, replace, delete
// remove is remove a specific entry.
// delete is delete user.
type UserOperation struct {
	// op
	//
	// x-displayName: "op"
	// x-example: ""op": "add""
	// op "add", "replace", "remove", "delete"
	Op string `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	// path
	//
	// x-displayName: "path"
	// x-example: ""path": "name.formatted""
	// path to the field where the change needs to happen.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// value
	//
	// x-displayName: "value"
	// x-example: ""value": "New Formatted Name""
	// value to be used for modifying the object. In case of delete nothing needs to be specified.
	Value *User `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UserOperation) Reset()      { *m = UserOperation{} }
func (*UserOperation) ProtoMessage() {}
func (*UserOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{4}
}
func (m *UserOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOperation.Merge(m, src)
}
func (m *UserOperation) XXX_Size() int {
	return m.Size()
}
func (m *UserOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOperation.DiscardUnknown(m)
}

var xxx_messageInfo_UserOperation proto.InternalMessageInfo

func (m *UserOperation) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *UserOperation) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *UserOperation) GetValue() *User {
	if m != nil {
		return m.Value
	}
	return nil
}

// PatchUserRequest
//
// x-displayName: "PatchUserRequest"
// x-example: {
//     "schemas": [
//         "urn:ietf:params:scim:api:messages:2.0:PatchOp"
//     ],
//    operation": {
//     "op": "add",
//     "path": "name.preferredName",
//     "value": {
//         "name": {
//             "preferredName": "New preferred Name"
//         }
//     }
// },
// "id": "1234-5678-901234"
//
// }
// PatchUserRequest patches the user object or deletes it.
type PatchUserRequest struct {
	// schemas
	//
	// x-displayName: "schemas"
	// x-example: "urn:ietf:params:scim:api:messages:2.0:PatchOp"
	// x-required
	// schemas for patch.
	Schemas []string `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// operation
	//
	// x-displayName: "operation"
	// x-example: ""operation": {
	//     "op": "add",
	//     "path": "name.preferredName",
	//     "value": {
	//         "name": {
	//             "preferredName": "New preferred Name"
	//         }
	//     }
	// }""
	// x-required
	// operation that will modify or delete the user object.
	Operation *UserOperation `protobuf:"bytes,2,opt,name=operation,proto3" json:"operation,omitempty"`
	// id
	//
	// x-displayName: "id"
	// x-example: ""id": "1234-5678-901234""
	// x-required
	// id of the user object that needs patching.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *PatchUserRequest) Reset()      { *m = PatchUserRequest{} }
func (*PatchUserRequest) ProtoMessage() {}
func (*PatchUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{5}
}
func (m *PatchUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatchUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PatchUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatchUserRequest.Merge(m, src)
}
func (m *PatchUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *PatchUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PatchUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PatchUserRequest proto.InternalMessageInfo

func (m *PatchUserRequest) GetSchemas() []string {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *PatchUserRequest) GetOperation() *UserOperation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *PatchUserRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// User
//
// x-displayName: "User"
// User object representing the user created.
type User struct {
	// schemas
	//
	// x-displayName: "schemas"
	// x-required
	// x-example: "urn:ietf:params:scim:schemas:core:2.0:User"
	// schemas for user object as per scim spec 2.0.
	Schemas []string `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// id
	//
	// x-displayName: "id"
	// x-required
	// x-example: "123-456-789012"
	// id for user object.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// meta
	//
	// x-displayName: "meta"
	// meta specifies the created date, location, resource type, modified time date and version.
	Meta *Meta `protobuf:"bytes,3,opt,name=meta,proto3" json:"meta,omitempty"`
	// externalId
	//
	// x-displayName: "externalId"
	// x-example: "rod_1234"
	// x-required
	// externalId specifies the id for the user object in external system.
	ExternalId string `protobuf:"bytes,4,opt,name=externalId,proto3" json:"externalId,omitempty"`
	// userName
	//
	// x-displayName: "userName"
	// x-required
	// x-example: "rod_1234"
	// userName for the user.
	UserName string `protobuf:"bytes,5,opt,name=userName,proto3" json:"userName,omitempty"`
	// name
	//
	// x-displayName: "name"
	// x-example: "Rodney Robilliard"
	// name of user.
	Name *Name `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// displayName
	//
	// x-displayName: "displayName"
	// x-example: "Rodney"
	// displayName for the user.
	DisplayName string `protobuf:"bytes,7,opt,name=displayName,proto3" json:"displayName,omitempty"`
	// nickName
	//
	// x-displayName: "nickName"
	// x-example: "Rod"
	// nickName for the user.
	NickName string `protobuf:"bytes,8,opt,name=nickName,proto3" json:"nickName,omitempty"`
	// userType
	//
	// x-displayName: "userType"
	// x-example: "Employee"
	// userType type of user.
	UserType user.UserType `protobuf:"varint,9,opt,name=userType,proto3,enum=ves.io.schema.user.UserType" json:"userType,omitempty"`
	// active
	//
	// x-displayName: "active"
	// x-example: "true/false"
	// active specifies if user is active or not.
	Active bool `protobuf:"varint,10,opt,name=active,proto3" json:"active,omitempty"`
	// emails
	//
	// x-displayName: "emails"
	// x-example: "test@email.com"
	// emails for the user whether primary or secondary.
	Emails []*Email `protobuf:"bytes,11,rep,name=emails,proto3" json:"emails,omitempty"`
	// groups
	//
	// x-displayName: "groups"
	// x-required
	// x-example: "group-id"
	// groups to which user is part of.
	Groups []*UserGroup `protobuf:"bytes,12,rep,name=groups,proto3" json:"groups,omitempty"`
	// roles
	//
	// x-displayName: "roles"
	// x-required
	// x-example: "roles"
	// roles defined for the user.
	Roles []string `protobuf:"bytes,13,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *User) Reset()      { *m = User{} }
func (*User) ProtoMessage() {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{6}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetSchemas() []string {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *User) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *User) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *User) GetName() *Name {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *User) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *User) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *User) GetUserType() user.UserType {
	if m != nil {
		return m.UserType
	}
	return user.USER
}

func (m *User) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *User) GetEmails() []*Email {
	if m != nil {
		return m.Emails
	}
	return nil
}

func (m *User) GetGroups() []*UserGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *User) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// ListUserResources
//
// x-displayName: "ListUserResources"
// ListUserResources list all the user objects.
type ListUserResponse struct {
	// schemas
	//
	// x-displayName: "schemas"
	// x-required
	// schemas for listing the user.
	Schemas []string `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// totalResults
	//
	// x-displayName: "totalResults"
	// x-required
	// totalResults for the search criteria.
	TotalResults uint64 `protobuf:"varint,2,opt,name=totalResults,proto3" json:"totalResults,omitempty"`
	// resources
	//
	// x-displayName: "resources"
	// x-required
	// resources representing all the user objects.
	Resources []*User `protobuf:"bytes,3,rep,name=resources,proto3" json:"resources,omitempty"`
}

func (m *ListUserResponse) Reset()      { *m = ListUserResponse{} }
func (*ListUserResponse) ProtoMessage() {}
func (*ListUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_adf5a512b1941f95, []int{7}
}
func (m *ListUserResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserResponse.Merge(m, src)
}
func (m *ListUserResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserResponse proto.InternalMessageInfo

func (m *ListUserResponse) GetSchemas() []string {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *ListUserResponse) GetTotalResults() uint64 {
	if m != nil {
		return m.TotalResults
	}
	return 0
}

func (m *ListUserResponse) GetResources() []*User {
	if m != nil {
		return m.Resources
	}
	return nil
}

func init() {
	proto.RegisterType((*Name)(nil), "ves.io.schema.scim.Name")
	golang_proto.RegisterType((*Name)(nil), "ves.io.schema.scim.Name")
	proto.RegisterType((*Email)(nil), "ves.io.schema.scim.Email")
	golang_proto.RegisterType((*Email)(nil), "ves.io.schema.scim.Email")
	proto.RegisterType((*UserGroup)(nil), "ves.io.schema.scim.UserGroup")
	golang_proto.RegisterType((*UserGroup)(nil), "ves.io.schema.scim.UserGroup")
	proto.RegisterType((*CreateUserRequest)(nil), "ves.io.schema.scim.CreateUserRequest")
	golang_proto.RegisterType((*CreateUserRequest)(nil), "ves.io.schema.scim.CreateUserRequest")
	proto.RegisterType((*UserOperation)(nil), "ves.io.schema.scim.UserOperation")
	golang_proto.RegisterType((*UserOperation)(nil), "ves.io.schema.scim.UserOperation")
	proto.RegisterType((*PatchUserRequest)(nil), "ves.io.schema.scim.PatchUserRequest")
	golang_proto.RegisterType((*PatchUserRequest)(nil), "ves.io.schema.scim.PatchUserRequest")
	proto.RegisterType((*User)(nil), "ves.io.schema.scim.User")
	golang_proto.RegisterType((*User)(nil), "ves.io.schema.scim.User")
	proto.RegisterType((*ListUserResponse)(nil), "ves.io.schema.scim.ListUserResponse")
	golang_proto.RegisterType((*ListUserResponse)(nil), "ves.io.schema.scim.ListUserResponse")
}

func init() {
	proto.RegisterFile("ves.io/schema/scim/user_types.proto", fileDescriptor_adf5a512b1941f95)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/scim/user_types.proto", fileDescriptor_adf5a512b1941f95)
}

var fileDescriptor_adf5a512b1941f95 = []byte{
	// 807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4d, 0x6f, 0x2b, 0x35,
	0x14, 0x8d, 0x33, 0x49, 0x9a, 0x38, 0x6d, 0x29, 0x16, 0x42, 0x43, 0x54, 0xac, 0x10, 0x36, 0x5d,
	0xd0, 0x19, 0x11, 0x04, 0x42, 0x48, 0x08, 0x09, 0x84, 0x00, 0xf1, 0x55, 0x0d, 0x74, 0xc3, 0xa6,
	0x72, 0x26, 0xce, 0xc4, 0xea, 0x4c, 0x3c, 0xd8, 0x9e, 0xd0, 0x2c, 0x90, 0x58, 0x21, 0x96, 0x48,
	0xfc, 0x09, 0xfe, 0x03, 0x1b, 0x96, 0x4f, 0x6f, 0xd5, 0xd5, 0x53, 0x97, 0xed, 0x64, 0xf3, 0x96,
	0xfd, 0x09, 0x4f, 0xf6, 0x7c, 0xe4, 0xa3, 0x49, 0xf4, 0x5e, 0x77, 0x73, 0xef, 0x3d, 0xf7, 0x5e,
	0xfb, 0x9c, 0x33, 0x32, 0x7c, 0x77, 0x4a, 0xa5, 0xc3, 0xb8, 0x2b, 0xfd, 0x31, 0x8d, 0x88, 0x2b,
	0x7d, 0x16, 0xb9, 0x89, 0xa4, 0xe2, 0x42, 0xcd, 0x62, 0x2a, 0x9d, 0x58, 0x70, 0xc5, 0x11, 0xca,
	0x40, 0x4e, 0x06, 0x72, 0x34, 0xa8, 0x73, 0x1a, 0x30, 0x35, 0x4e, 0x06, 0x8e, 0xcf, 0x23, 0x37,
	0xe0, 0x01, 0x77, 0x0d, 0x74, 0x90, 0x8c, 0x4c, 0x64, 0x02, 0xf3, 0x95, 0x8d, 0xe8, 0xe0, 0x0d,
	0x7b, 0x96, 0x56, 0xac, 0xd7, 0xf5, 0x11, 0x56, 0xea, 0xdd, 0xd5, 0xfa, 0x94, 0xd1, 0xdf, 0x2e,
	0x78, 0xac, 0x18, 0x9f, 0xe4, 0x88, 0xde, 0x33, 0x00, 0x6b, 0x3f, 0x90, 0x88, 0xa2, 0x63, 0xd8,
	0x1a, 0x71, 0x11, 0x11, 0xa5, 0xe8, 0xd0, 0x06, 0x5d, 0x70, 0xd2, 0xf2, 0x16, 0x09, 0x84, 0x21,
	0x1c, 0x91, 0x88, 0x85, 0x33, 0x8d, 0xb5, 0xab, 0xa6, 0xbc, 0x94, 0xd1, 0xdd, 0x01, 0x9b, 0xd2,
	0x89, 0x29, 0x5b, 0x59, 0x77, 0x99, 0xd0, 0xdd, 0x11, 0x1b, 0x0e, 0x43, 0x6a, 0xca, 0xb5, 0xac,
	0x7b, 0x91, 0x41, 0x27, 0xf0, 0xb5, 0x31, 0x9f, 0x70, 0xc1, 0x46, 0xcc, 0x3f, 0x13, 0x74, 0xc4,
	0xae, 0xec, 0xba, 0x01, 0xad, 0xa7, 0x57, 0x90, 0x3f, 0x25, 0x23, 0x8d, 0x6c, 0xac, 0x21, 0xb3,
	0x74, 0xef, 0x5b, 0x58, 0xff, 0x32, 0x22, 0x2c, 0x44, 0x6f, 0xc0, 0xfa, 0x94, 0x84, 0x09, 0xcd,
	0x2f, 0x95, 0x05, 0x08, 0xc1, 0x9a, 0x26, 0x2a, 0xbf, 0x8a, 0xf9, 0x46, 0x36, 0xdc, 0x8b, 0x05,
	0x8b, 0x88, 0x98, 0x99, 0x2b, 0x34, 0xbd, 0x22, 0xec, 0x7d, 0x0a, 0x5b, 0xe7, 0x92, 0x8a, 0xaf,
	0x04, 0x4f, 0x62, 0x0d, 0x1b, 0x32, 0x19, 0x87, 0x64, 0x96, 0x8f, 0x2c, 0x42, 0x74, 0x08, 0xab,
	0x6c, 0x98, 0x8f, 0xac, 0xb2, 0xe1, 0x27, 0x8d, 0xa7, 0xff, 0x81, 0xea, 0x11, 0xe8, 0xfd, 0x63,
	0xc1, 0xd7, 0xbf, 0x10, 0x94, 0x28, 0xaa, 0xa7, 0x78, 0xf4, 0xd7, 0x84, 0x4a, 0xa5, 0xe7, 0x64,
	0xba, 0x48, 0x1b, 0x74, 0x2d, 0x3d, 0x27, 0x0f, 0x35, 0x5f, 0xf4, 0x4a, 0x51, 0x31, 0x21, 0xe1,
	0x37, 0xc5, 0xbc, 0xa5, 0x0c, 0xea, 0xc0, 0xa6, 0x96, 0x7a, 0x89, 0xec, 0x32, 0x46, 0xef, 0xc1,
	0xda, 0xa4, 0x60, 0xb9, 0xdd, 0xb7, 0x9d, 0x87, 0x26, 0x74, 0x34, 0xce, 0x33, 0x28, 0xd4, 0x85,
	0xed, 0xfc, 0xf0, 0x66, 0x58, 0xc6, 0xfa, 0x72, 0x0a, 0x7d, 0x9c, 0xed, 0xfa, 0x59, 0x93, 0xa5,
	0xa9, 0x3e, 0xec, 0x1f, 0xaf, 0xcd, 0xd4, 0x65, 0xe7, 0x3c, 0xc7, 0x78, 0x25, 0x1a, 0xbd, 0x09,
	0x1b, 0xc4, 0x57, 0x6c, 0x4a, 0xed, 0x3d, 0xc3, 0x66, 0x1e, 0xa1, 0xf7, 0x61, 0x83, 0x6a, 0x65,
	0xa4, 0xdd, 0xec, 0x5a, 0x27, 0xed, 0xfe, 0x5b, 0x9b, 0xce, 0x68, 0xb4, 0xf3, 0x72, 0x20, 0xfa,
	0x10, 0x36, 0x02, 0xcd, 0xbd, 0xb4, 0x5b, 0xa6, 0xe5, 0xed, 0x4d, 0x2d, 0xa5, 0x42, 0x5e, 0x0e,
	0xd6, 0xd2, 0x0b, 0x1e, 0x52, 0x69, 0x43, 0xc3, 0x6f, 0x16, 0x94, 0xaa, 0xf8, 0xf0, 0x40, 0xb7,
	0xfc, 0x18, 0x53, 0x41, 0xf4, 0x2f, 0xa1, 0xe5, 0xe3, 0x71, 0xae, 0x69, 0x95, 0xc7, 0xda, 0x23,
	0x31, 0x51, 0xe3, 0xc2, 0x23, 0xfa, 0x1b, 0x39, 0x85, 0x9b, 0xac, 0xed, 0xfc, 0x1a, 0x91, 0x33,
	0x58, 0xef, 0x77, 0x78, 0x74, 0x46, 0x94, 0x3f, 0x7e, 0x39, 0xe1, 0x3f, 0x83, 0x2d, 0x5e, 0x1c,
	0xc7, 0xac, 0x6d, 0xf7, 0xdf, 0xd9, 0xb6, 0xa1, 0x3c, 0xb7, 0xb7, 0xe8, 0xc9, 0x1d, 0x68, 0x15,
	0x0e, 0xec, 0xdd, 0x5a, 0xb0, 0xa6, 0xc1, 0x3b, 0x76, 0xae, 0x99, 0x56, 0x1b, 0x28, 0xa2, 0x8a,
	0xec, 0xba, 0xe0, 0xf7, 0x54, 0x11, 0xcf, 0xa0, 0xd6, 0xac, 0x5a, 0xdb, 0x69, 0xd5, 0xfa, 0x16,
	0xab, 0x36, 0x1e, 0x63, 0xd5, 0xbd, 0x87, 0x56, 0xed, 0xc0, 0xe6, 0x84, 0xf9, 0x97, 0xa6, 0xdc,
	0xcc, 0x76, 0x15, 0xf1, 0x8a, 0x8d, 0x5b, 0x8f, 0xb4, 0x31, 0xdc, 0x62, 0xe3, 0xf6, 0xab, 0xdb,
	0x78, 0xff, 0x51, 0x36, 0x3e, 0xd8, 0x64, 0xe3, 0xbf, 0x00, 0x3c, 0xfa, 0x8e, 0x49, 0x95, 0x39,
	0x4c, 0xc6, 0x7c, 0x22, 0xe9, 0x0e, 0xb9, 0x7b, 0x70, 0x5f, 0x71, 0x45, 0x42, 0x8f, 0xca, 0x24,
	0x54, 0xd2, 0x08, 0x5f, 0xf3, 0x56, 0x72, 0xe8, 0x23, 0xd8, 0x12, 0x54, 0xf2, 0x44, 0xf8, 0x54,
	0xda, 0x96, 0x39, 0xea, 0x76, 0xa3, 0x2f, 0xa0, 0x9f, 0xff, 0x09, 0xae, 0xef, 0x70, 0xe5, 0xe6,
	0x0e, 0x57, 0xee, 0xef, 0x30, 0xf8, 0x23, 0xc5, 0xe0, 0xdf, 0x14, 0x83, 0x27, 0x29, 0x06, 0xd7,
	0x29, 0x06, 0x37, 0x29, 0x06, 0xb7, 0x29, 0x06, 0xcf, 0x53, 0x5c, 0xb9, 0x4f, 0x31, 0xf8, 0x7b,
	0x8e, 0x2b, 0xff, 0xcf, 0x31, 0xb8, 0x9e, 0xe3, 0xca, 0xcd, 0x1c, 0x57, 0x7e, 0xf9, 0x3a, 0xe0,
	0xf1, 0x65, 0xe0, 0x4c, 0x79, 0xa8, 0xa8, 0x10, 0x5a, 0x11, 0xd7, 0x7c, 0xe8, 0x67, 0xe8, 0x34,
	0x16, 0x7c, 0xca, 0x86, 0x54, 0x9c, 0x16, 0x65, 0x37, 0x1e, 0x04, 0xdc, 0xa5, 0x57, 0xaa, 0x7c,
	0x1c, 0xcb, 0x37, 0x72, 0xd0, 0x30, 0x8f, 0xdb, 0x07, 0x2f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x3f,
	0x87, 0x0a, 0x61, 0xa8, 0x07, 0x00, 0x00,
}

func (this *Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Name)
	if !ok {
		that2, ok := that.(Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Formatted != that1.Formatted {
		return false
	}
	if this.FamilyName != that1.FamilyName {
		return false
	}
	if this.GivenName != that1.GivenName {
		return false
	}
	if this.MiddleName != that1.MiddleName {
		return false
	}
	if this.HonorificPrefix != that1.HonorificPrefix {
		return false
	}
	if this.HonorificSuffix != that1.HonorificSuffix {
		return false
	}
	return true
}
func (this *Email) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Email)
	if !ok {
		that2, ok := that.(Email)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Primary != that1.Primary {
		return false
	}
	return true
}
func (this *UserGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserGroup)
	if !ok {
		that2, ok := that.(UserGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Display != that1.Display {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *CreateUserRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateUserRequest)
	if !ok {
		that2, ok := that.(CreateUserRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Schemas) != len(that1.Schemas) {
		return false
	}
	for i := range this.Schemas {
		if this.Schemas[i] != that1.Schemas[i] {
			return false
		}
	}
	if this.ExternalId != that1.ExternalId {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if this.UserType != that1.UserType {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if len(this.Emails) != len(that1.Emails) {
		return false
	}
	for i := range this.Emails {
		if !this.Emails[i].Equal(that1.Emails[i]) {
			return false
		}
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	return true
}
func (this *UserOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserOperation)
	if !ok {
		that2, ok := that.(UserOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *PatchUserRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PatchUserRequest)
	if !ok {
		that2, ok := that.(PatchUserRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Schemas) != len(that1.Schemas) {
		return false
	}
	for i := range this.Schemas {
		if this.Schemas[i] != that1.Schemas[i] {
			return false
		}
	}
	if !this.Operation.Equal(that1.Operation) {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*User)
	if !ok {
		that2, ok := that.(User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Schemas) != len(that1.Schemas) {
		return false
	}
	for i := range this.Schemas {
		if this.Schemas[i] != that1.Schemas[i] {
			return false
		}
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Meta.Equal(that1.Meta) {
		return false
	}
	if this.ExternalId != that1.ExternalId {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	if this.NickName != that1.NickName {
		return false
	}
	if this.UserType != that1.UserType {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if len(this.Emails) != len(that1.Emails) {
		return false
	}
	for i := range this.Emails {
		if !this.Emails[i].Equal(that1.Emails[i]) {
			return false
		}
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	return true
}
func (this *ListUserResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserResponse)
	if !ok {
		that2, ok := that.(ListUserResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Schemas) != len(that1.Schemas) {
		return false
	}
	for i := range this.Schemas {
		if this.Schemas[i] != that1.Schemas[i] {
			return false
		}
	}
	if this.TotalResults != that1.TotalResults {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&scim.Name{")
	s = append(s, "Formatted: "+fmt.Sprintf("%#v", this.Formatted)+",\n")
	s = append(s, "FamilyName: "+fmt.Sprintf("%#v", this.FamilyName)+",\n")
	s = append(s, "GivenName: "+fmt.Sprintf("%#v", this.GivenName)+",\n")
	s = append(s, "MiddleName: "+fmt.Sprintf("%#v", this.MiddleName)+",\n")
	s = append(s, "HonorificPrefix: "+fmt.Sprintf("%#v", this.HonorificPrefix)+",\n")
	s = append(s, "HonorificSuffix: "+fmt.Sprintf("%#v", this.HonorificSuffix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Email) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&scim.Email{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Primary: "+fmt.Sprintf("%#v", this.Primary)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&scim.UserGroup{")
	s = append(s, "Display: "+fmt.Sprintf("%#v", this.Display)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateUserRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&scim.CreateUserRequest{")
	s = append(s, "Schemas: "+fmt.Sprintf("%#v", this.Schemas)+",\n")
	s = append(s, "ExternalId: "+fmt.Sprintf("%#v", this.ExternalId)+",\n")
	s = append(s, "UserName: "+fmt.Sprintf("%#v", this.UserName)+",\n")
	if this.Name != nil {
		s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	}
	s = append(s, "DisplayName: "+fmt.Sprintf("%#v", this.DisplayName)+",\n")
	s = append(s, "UserType: "+fmt.Sprintf("%#v", this.UserType)+",\n")
	s = append(s, "Active: "+fmt.Sprintf("%#v", this.Active)+",\n")
	if this.Emails != nil {
		s = append(s, "Emails: "+fmt.Sprintf("%#v", this.Emails)+",\n")
	}
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	s = append(s, "Roles: "+fmt.Sprintf("%#v", this.Roles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserOperation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&scim.UserOperation{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PatchUserRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&scim.PatchUserRequest{")
	s = append(s, "Schemas: "+fmt.Sprintf("%#v", this.Schemas)+",\n")
	if this.Operation != nil {
		s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	}
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *User) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&scim.User{")
	s = append(s, "Schemas: "+fmt.Sprintf("%#v", this.Schemas)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Meta != nil {
		s = append(s, "Meta: "+fmt.Sprintf("%#v", this.Meta)+",\n")
	}
	s = append(s, "ExternalId: "+fmt.Sprintf("%#v", this.ExternalId)+",\n")
	s = append(s, "UserName: "+fmt.Sprintf("%#v", this.UserName)+",\n")
	if this.Name != nil {
		s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	}
	s = append(s, "DisplayName: "+fmt.Sprintf("%#v", this.DisplayName)+",\n")
	s = append(s, "NickName: "+fmt.Sprintf("%#v", this.NickName)+",\n")
	s = append(s, "UserType: "+fmt.Sprintf("%#v", this.UserType)+",\n")
	s = append(s, "Active: "+fmt.Sprintf("%#v", this.Active)+",\n")
	if this.Emails != nil {
		s = append(s, "Emails: "+fmt.Sprintf("%#v", this.Emails)+",\n")
	}
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	s = append(s, "Roles: "+fmt.Sprintf("%#v", this.Roles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&scim.ListUserResponse{")
	s = append(s, "Schemas: "+fmt.Sprintf("%#v", this.Schemas)+",\n")
	s = append(s, "TotalResults: "+fmt.Sprintf("%#v", this.TotalResults)+",\n")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringUserTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Name) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HonorificSuffix) > 0 {
		i -= len(m.HonorificSuffix)
		copy(dAtA[i:], m.HonorificSuffix)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.HonorificSuffix)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HonorificPrefix) > 0 {
		i -= len(m.HonorificPrefix)
		copy(dAtA[i:], m.HonorificPrefix)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.HonorificPrefix)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MiddleName) > 0 {
		i -= len(m.MiddleName)
		copy(dAtA[i:], m.MiddleName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.MiddleName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GivenName) > 0 {
		i -= len(m.GivenName)
		copy(dAtA[i:], m.GivenName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.GivenName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FamilyName) > 0 {
		i -= len(m.FamilyName)
		copy(dAtA[i:], m.FamilyName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.FamilyName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Formatted) > 0 {
		i -= len(m.Formatted)
		copy(dAtA[i:], m.Formatted)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Formatted)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Email) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Email) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Email) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Display) > 0 {
		i -= len(m.Display)
		copy(dAtA[i:], m.Display)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Display)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateUserRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Emails) > 0 {
		for iNdEx := len(m.Emails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.UserType != 0 {
		i = encodeVarintUserTypes(dAtA, i, uint64(m.UserType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Name != nil {
		{
			size, err := m.Name.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUserTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Schemas[iNdEx])
			copy(dAtA[i:], m.Schemas[iNdEx])
			i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Schemas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUserTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatchUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatchUserRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatchUserRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUserTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Schemas[iNdEx])
			copy(dAtA[i:], m.Schemas[iNdEx])
			i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Schemas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Emails) > 0 {
		for iNdEx := len(m.Emails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UserType != 0 {
		i = encodeVarintUserTypes(dAtA, i, uint64(m.UserType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.NickName) > 0 {
		i -= len(m.NickName)
		copy(dAtA[i:], m.NickName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.NickName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Name != nil {
		{
			size, err := m.Name.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUserTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUserTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Schemas[iNdEx])
			copy(dAtA[i:], m.Schemas[iNdEx])
			i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Schemas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUserResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalResults != 0 {
		i = encodeVarintUserTypes(dAtA, i, uint64(m.TotalResults))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Schemas[iNdEx])
			copy(dAtA[i:], m.Schemas[iNdEx])
			i = encodeVarintUserTypes(dAtA, i, uint64(len(m.Schemas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintUserTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovUserTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Formatted)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.FamilyName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.GivenName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.MiddleName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.HonorificPrefix)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.HonorificSuffix)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	return n
}

func (m *Email) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	return n
}

func (m *UserGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Display)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	return n
}

func (m *CreateUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for _, s := range m.Schemas {
			l = len(s)
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.UserType != 0 {
		n += 1 + sovUserTypes(uint64(m.UserType))
	}
	if m.Active {
		n += 2
	}
	if len(m.Emails) > 0 {
		for _, e := range m.Emails {
			l = e.Size()
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	return n
}

func (m *UserOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovUserTypes(uint64(l))
	}
	return n
}

func (m *PatchUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for _, s := range m.Schemas {
			l = len(s)
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for _, s := range m.Schemas {
			l = len(s)
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovUserTypes(uint64(l))
	}
	if m.UserType != 0 {
		n += 1 + sovUserTypes(uint64(m.UserType))
	}
	if m.Active {
		n += 2
	}
	if len(m.Emails) > 0 {
		for _, e := range m.Emails {
			l = e.Size()
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	return n
}

func (m *ListUserResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for _, s := range m.Schemas {
			l = len(s)
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	if m.TotalResults != 0 {
		n += 1 + sovUserTypes(uint64(m.TotalResults))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovUserTypes(uint64(l))
		}
	}
	return n
}

func sovUserTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUserTypes(x uint64) (n int) {
	return sovUserTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Name{`,
		`Formatted:` + fmt.Sprintf("%v", this.Formatted) + `,`,
		`FamilyName:` + fmt.Sprintf("%v", this.FamilyName) + `,`,
		`GivenName:` + fmt.Sprintf("%v", this.GivenName) + `,`,
		`MiddleName:` + fmt.Sprintf("%v", this.MiddleName) + `,`,
		`HonorificPrefix:` + fmt.Sprintf("%v", this.HonorificPrefix) + `,`,
		`HonorificSuffix:` + fmt.Sprintf("%v", this.HonorificSuffix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Email) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Email{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Primary:` + fmt.Sprintf("%v", this.Primary) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserGroup{`,
		`Display:` + fmt.Sprintf("%v", this.Display) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateUserRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEmails := "[]*Email{"
	for _, f := range this.Emails {
		repeatedStringForEmails += strings.Replace(f.String(), "Email", "Email", 1) + ","
	}
	repeatedStringForEmails += "}"
	repeatedStringForGroups := "[]*UserGroup{"
	for _, f := range this.Groups {
		repeatedStringForGroups += strings.Replace(f.String(), "UserGroup", "UserGroup", 1) + ","
	}
	repeatedStringForGroups += "}"
	s := strings.Join([]string{`&CreateUserRequest{`,
		`Schemas:` + fmt.Sprintf("%v", this.Schemas) + `,`,
		`ExternalId:` + fmt.Sprintf("%v", this.ExternalId) + `,`,
		`UserName:` + fmt.Sprintf("%v", this.UserName) + `,`,
		`Name:` + strings.Replace(this.Name.String(), "Name", "Name", 1) + `,`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`UserType:` + fmt.Sprintf("%v", this.UserType) + `,`,
		`Active:` + fmt.Sprintf("%v", this.Active) + `,`,
		`Emails:` + repeatedStringForEmails + `,`,
		`Groups:` + repeatedStringForGroups + `,`,
		`Roles:` + fmt.Sprintf("%v", this.Roles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserOperation{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Value:` + strings.Replace(this.Value.String(), "User", "User", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PatchUserRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PatchUserRequest{`,
		`Schemas:` + fmt.Sprintf("%v", this.Schemas) + `,`,
		`Operation:` + strings.Replace(this.Operation.String(), "UserOperation", "UserOperation", 1) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *User) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEmails := "[]*Email{"
	for _, f := range this.Emails {
		repeatedStringForEmails += strings.Replace(f.String(), "Email", "Email", 1) + ","
	}
	repeatedStringForEmails += "}"
	repeatedStringForGroups := "[]*UserGroup{"
	for _, f := range this.Groups {
		repeatedStringForGroups += strings.Replace(f.String(), "UserGroup", "UserGroup", 1) + ","
	}
	repeatedStringForGroups += "}"
	s := strings.Join([]string{`&User{`,
		`Schemas:` + fmt.Sprintf("%v", this.Schemas) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Meta:` + strings.Replace(fmt.Sprintf("%v", this.Meta), "Meta", "Meta", 1) + `,`,
		`ExternalId:` + fmt.Sprintf("%v", this.ExternalId) + `,`,
		`UserName:` + fmt.Sprintf("%v", this.UserName) + `,`,
		`Name:` + strings.Replace(this.Name.String(), "Name", "Name", 1) + `,`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`NickName:` + fmt.Sprintf("%v", this.NickName) + `,`,
		`UserType:` + fmt.Sprintf("%v", this.UserType) + `,`,
		`Active:` + fmt.Sprintf("%v", this.Active) + `,`,
		`Emails:` + repeatedStringForEmails + `,`,
		`Groups:` + repeatedStringForGroups + `,`,
		`Roles:` + fmt.Sprintf("%v", this.Roles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResources := "[]*User{"
	for _, f := range this.Resources {
		repeatedStringForResources += strings.Replace(f.String(), "User", "User", 1) + ","
	}
	repeatedStringForResources += "}"
	s := strings.Join([]string{`&ListUserResponse{`,
		`Schemas:` + fmt.Sprintf("%v", this.Schemas) + `,`,
		`TotalResults:` + fmt.Sprintf("%v", this.TotalResults) + `,`,
		`Resources:` + repeatedStringForResources + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringUserTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Name) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Name: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Name: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formatted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Formatted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GivenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GivenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiddleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MiddleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HonorificPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HonorificPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HonorificSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HonorificSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Email) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Email: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Email: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Display = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &Name{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserType", wireType)
			}
			m.UserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserType |= user.UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emails = append(m.Emails, &Email{})
			if err := m.Emails[len(m.Emails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &UserGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &User{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatchUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatchUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatchUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operation == nil {
				m.Operation = &UserOperation{}
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Meta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &Name{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserType", wireType)
			}
			m.UserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserType |= user.UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emails = append(m.Emails, &Email{})
			if err := m.Emails[len(m.Emails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &UserGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResults", wireType)
			}
			m.TotalResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalResults |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &User{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthUserTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUserTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUserTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUserTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUserTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUserTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUserTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUserTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUserTypes = fmt.Errorf("proto: unexpected end of group")
)
