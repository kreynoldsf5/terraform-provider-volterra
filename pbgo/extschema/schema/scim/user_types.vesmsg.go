//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package scim

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateUserRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateUserRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateUserRequest) DeepCopy() *CreateUserRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateUserRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateUserRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateUserRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateUserRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCreateUserRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateUserRequest) RolesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for roles")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for roles")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated roles")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items roles")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateUserRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateUserRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateUserRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active"]; exists {

		vOpts := append(opts, db.WithValidateField("active"))
		if err := fv(ctx, m.GetActive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["displayName"]; exists {

		vOpts := append(opts, db.WithValidateField("displayName"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["emails"]; exists {

		vOpts := append(opts, db.WithValidateField("emails"))
		for idx, item := range m.GetEmails() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["externalId"]; exists {

		vOpts := append(opts, db.WithValidateField("externalId"))
		if err := fv(ctx, m.GetExternalId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["groups"]; exists {

		vOpts := append(opts, db.WithValidateField("groups"))
		for idx, item := range m.GetGroups() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["roles"]; exists {
		vOpts := append(opts, db.WithValidateField("roles"))
		if err := fv(ctx, m.GetRoles(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["schemas"]; exists {

		vOpts := append(opts, db.WithValidateField("schemas"))
		for idx, item := range m.GetSchemas() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["userName"]; exists {

		vOpts := append(opts, db.WithValidateField("userName"))
		if err := fv(ctx, m.GetUserName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["userType"]; exists {

		vOpts := append(opts, db.WithValidateField("userType"))
		if err := fv(ctx, m.GetUserType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateUserRequestValidator = func() *ValidateCreateUserRequest {
	v := &ValidateCreateUserRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoles := v.RolesValidationRuleHandler
	rulesRoles := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRoles(rulesRoles)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateUserRequest.roles: %s", err)
		panic(errMsg)
	}
	v.FldValidators["roles"] = vFn

	return v
}()

func CreateUserRequestValidator() db.Validator {
	return DefaultCreateUserRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *Email) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Email) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Email) DeepCopy() *Email {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Email{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Email) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Email) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EmailValidator().Validate(ctx, m, opts...)
}

type ValidateEmail struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEmail) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Email)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Email got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["primary"]; exists {

		vOpts := append(opts, db.WithValidateField("primary"))
		if err := fv(ctx, m.GetPrimary(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEmailValidator = func() *ValidateEmail {
	v := &ValidateEmail{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EmailValidator() db.Validator {
	return DefaultEmailValidator
}

// augmented methods on protoc/std generated struct

func (m *ListUserResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListUserResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListUserResponse) DeepCopy() *ListUserResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListUserResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListUserResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListUserResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListUserResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListUserResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListUserResponse) SchemasValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for schemas")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for schemas")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated schemas")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items schemas")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateListUserResponse) TotalResultsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint64ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for totalResults")
	}

	return validatorFn, nil
}

func (v *ValidateListUserResponse) ResourcesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*User, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := UserValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for resources")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*User)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*User, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated resources")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items resources")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateListUserResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListUserResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListUserResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["resources"]; exists {
		vOpts := append(opts, db.WithValidateField("resources"))
		if err := fv(ctx, m.GetResources(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["schemas"]; exists {
		vOpts := append(opts, db.WithValidateField("schemas"))
		if err := fv(ctx, m.GetSchemas(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["totalResults"]; exists {

		vOpts := append(opts, db.WithValidateField("totalResults"))
		if err := fv(ctx, m.GetTotalResults(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListUserResponseValidator = func() *ValidateListUserResponse {
	v := &ValidateListUserResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSchemas := v.SchemasValidationRuleHandler
	rulesSchemas := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSchemas(rulesSchemas)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListUserResponse.schemas: %s", err)
		panic(errMsg)
	}
	v.FldValidators["schemas"] = vFn

	vrhTotalResults := v.TotalResultsValidationRuleHandler
	rulesTotalResults := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTotalResults(rulesTotalResults)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListUserResponse.totalResults: %s", err)
		panic(errMsg)
	}
	v.FldValidators["totalResults"] = vFn

	vrhResources := v.ResourcesValidationRuleHandler
	rulesResources := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhResources(rulesResources)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListUserResponse.resources: %s", err)
		panic(errMsg)
	}
	v.FldValidators["resources"] = vFn

	return v
}()

func ListUserResponseValidator() db.Validator {
	return DefaultListUserResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *Name) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Name) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Name) DeepCopy() *Name {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Name{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Name) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Name) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NameValidator().Validate(ctx, m, opts...)
}

type ValidateName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Name)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Name got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["familyName"]; exists {

		vOpts := append(opts, db.WithValidateField("familyName"))
		if err := fv(ctx, m.GetFamilyName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["formatted"]; exists {

		vOpts := append(opts, db.WithValidateField("formatted"))
		if err := fv(ctx, m.GetFormatted(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["givenName"]; exists {

		vOpts := append(opts, db.WithValidateField("givenName"))
		if err := fv(ctx, m.GetGivenName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["honorificPrefix"]; exists {

		vOpts := append(opts, db.WithValidateField("honorificPrefix"))
		if err := fv(ctx, m.GetHonorificPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["honorificSuffix"]; exists {

		vOpts := append(opts, db.WithValidateField("honorificSuffix"))
		if err := fv(ctx, m.GetHonorificSuffix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["middleName"]; exists {

		vOpts := append(opts, db.WithValidateField("middleName"))
		if err := fv(ctx, m.GetMiddleName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNameValidator = func() *ValidateName {
	v := &ValidateName{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NameValidator() db.Validator {
	return DefaultNameValidator
}

// augmented methods on protoc/std generated struct

func (m *PatchUserRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PatchUserRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PatchUserRequest) DeepCopy() *PatchUserRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PatchUserRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PatchUserRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PatchUserRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PatchUserRequestValidator().Validate(ctx, m, opts...)
}

type ValidatePatchUserRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePatchUserRequest) SchemasValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for schemas")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for schemas")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated schemas")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items schemas")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePatchUserRequest) OperationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for operation")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePatchUserRequest) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidatePatchUserRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PatchUserRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PatchUserRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operation"]; exists {

		vOpts := append(opts, db.WithValidateField("operation"))
		if err := fv(ctx, m.GetOperation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["schemas"]; exists {
		vOpts := append(opts, db.WithValidateField("schemas"))
		if err := fv(ctx, m.GetSchemas(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPatchUserRequestValidator = func() *ValidatePatchUserRequest {
	v := &ValidatePatchUserRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSchemas := v.SchemasValidationRuleHandler
	rulesSchemas := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSchemas(rulesSchemas)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PatchUserRequest.schemas: %s", err)
		panic(errMsg)
	}
	v.FldValidators["schemas"] = vFn

	vrhOperation := v.OperationValidationRuleHandler
	rulesOperation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOperation(rulesOperation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PatchUserRequest.operation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operation"] = vFn

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PatchUserRequest.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	return v
}()

func PatchUserRequestValidator() db.Validator {
	return DefaultPatchUserRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *User) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *User) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *User) DeepCopy() *User {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &User{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *User) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *User) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserValidator().Validate(ctx, m, opts...)
}

type ValidateUser struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUser) SchemasValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for schemas")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for schemas")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated schemas")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items schemas")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateUser) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateUser) ExternalIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for externalId")
	}

	return validatorFn, nil
}

func (v *ValidateUser) UserNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for userName")
	}

	return validatorFn, nil
}

func (v *ValidateUser) GroupsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*UserGroup, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := UserGroupValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for groups")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*UserGroup)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*UserGroup, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated groups")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items groups")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateUser) RolesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for roles")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for roles")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated roles")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items roles")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateUser) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*User)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *User got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active"]; exists {

		vOpts := append(opts, db.WithValidateField("active"))
		if err := fv(ctx, m.GetActive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["displayName"]; exists {

		vOpts := append(opts, db.WithValidateField("displayName"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["emails"]; exists {

		vOpts := append(opts, db.WithValidateField("emails"))
		for idx, item := range m.GetEmails() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["externalId"]; exists {

		vOpts := append(opts, db.WithValidateField("externalId"))
		if err := fv(ctx, m.GetExternalId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["groups"]; exists {
		vOpts := append(opts, db.WithValidateField("groups"))
		if err := fv(ctx, m.GetGroups(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["meta"]; exists {

		vOpts := append(opts, db.WithValidateField("meta"))
		if err := fv(ctx, m.GetMeta(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nickName"]; exists {

		vOpts := append(opts, db.WithValidateField("nickName"))
		if err := fv(ctx, m.GetNickName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["roles"]; exists {
		vOpts := append(opts, db.WithValidateField("roles"))
		if err := fv(ctx, m.GetRoles(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["schemas"]; exists {
		vOpts := append(opts, db.WithValidateField("schemas"))
		if err := fv(ctx, m.GetSchemas(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["userName"]; exists {

		vOpts := append(opts, db.WithValidateField("userName"))
		if err := fv(ctx, m.GetUserName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["userType"]; exists {

		vOpts := append(opts, db.WithValidateField("userType"))
		if err := fv(ctx, m.GetUserType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserValidator = func() *ValidateUser {
	v := &ValidateUser{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSchemas := v.SchemasValidationRuleHandler
	rulesSchemas := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSchemas(rulesSchemas)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for User.schemas: %s", err)
		panic(errMsg)
	}
	v.FldValidators["schemas"] = vFn

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for User.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhExternalId := v.ExternalIdValidationRuleHandler
	rulesExternalId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhExternalId(rulesExternalId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for User.externalId: %s", err)
		panic(errMsg)
	}
	v.FldValidators["externalId"] = vFn

	vrhUserName := v.UserNameValidationRuleHandler
	rulesUserName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUserName(rulesUserName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for User.userName: %s", err)
		panic(errMsg)
	}
	v.FldValidators["userName"] = vFn

	vrhGroups := v.GroupsValidationRuleHandler
	rulesGroups := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhGroups(rulesGroups)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for User.groups: %s", err)
		panic(errMsg)
	}
	v.FldValidators["groups"] = vFn

	vrhRoles := v.RolesValidationRuleHandler
	rulesRoles := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRoles(rulesRoles)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for User.roles: %s", err)
		panic(errMsg)
	}
	v.FldValidators["roles"] = vFn

	v.FldValidators["meta"] = MetaValidator().Validate

	return v
}()

func UserValidator() db.Validator {
	return DefaultUserValidator
}

// augmented methods on protoc/std generated struct

func (m *UserGroup) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserGroup) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserGroup) DeepCopy() *UserGroup {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserGroup{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserGroup) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserGroup) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserGroupValidator().Validate(ctx, m, opts...)
}

type ValidateUserGroup struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserGroup) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserGroup)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserGroup got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["display"]; exists {

		vOpts := append(opts, db.WithValidateField("display"))
		if err := fv(ctx, m.GetDisplay(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserGroupValidator = func() *ValidateUserGroup {
	v := &ValidateUserGroup{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UserGroupValidator() db.Validator {
	return DefaultUserGroupValidator
}

// augmented methods on protoc/std generated struct

func (m *UserOperation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserOperation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserOperation) DeepCopy() *UserOperation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserOperation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserOperation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserOperation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserOperationValidator().Validate(ctx, m, opts...)
}

type ValidateUserOperation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserOperation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserOperation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserOperation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserOperationValidator = func() *ValidateUserOperation {
	v := &ValidateUserOperation{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["value"] = UserValidator().Validate

	return v
}()

func UserOperationValidator() db.Validator {
	return DefaultUserOperationValidator
}
