// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/scim/types.proto

package scim

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Meta
//
// x-displayName: "Meta"
// x-example: "Meta"
// x-required
// Resource meta information..
type Meta struct {
	// resourceType
	//
	// x-displayName: "schemas"
	// x-example: "User"
	// x-required
	// type of resource.
	ResourceType string `protobuf:"bytes,1,opt,name=resourceType,proto3" json:"resourceType,omitempty"`
	// created
	//
	// x-displayName: "created"
	// x-example: "2011-08-08T04:56:22Z"
	// x-required
	// create date.
	Created string `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// lastModified
	//
	// x-displayName: "lastModified"
	// x-example: "2011-08-08T08:00:12Z"
	// x-required
	// last modification date and time.
	LastModified string `protobuf:"bytes,3,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
	//location
	//
	// x-displayName: "location"
	// x-example: "/ResourceType/Users"
	// [x-required]
	// location for resource.
	Location string `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	// version
	//
	// x-displayName: "version"
	// x-example: "2.0"
	// x-required
	// version for resource type.
	Version string `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Meta) Reset()      { *m = Meta{} }
func (*Meta) ProtoMessage() {}
func (*Meta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{0}
}
func (m *Meta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Meta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meta.Merge(m, src)
}
func (m *Meta) XXX_Size() int {
	return m.Size()
}
func (m *Meta) XXX_DiscardUnknown() {
	xxx_messageInfo_Meta.DiscardUnknown(m)
}

var xxx_messageInfo_Meta proto.InternalMessageInfo

func (m *Meta) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *Meta) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *Meta) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *Meta) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Meta) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Support
//
// x-displayName: "Support"
// Support.
type Support struct {
	// supported
	//
	// x-displayName: "supported"
	// x-example: "true/false"
	// x-required
	// is support supported.
	Supported bool `protobuf:"varint,1,opt,name=supported,proto3" json:"supported,omitempty"`
}

func (m *Support) Reset()      { *m = Support{} }
func (*Support) ProtoMessage() {}
func (*Support) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{1}
}
func (m *Support) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Support) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Support) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Support.Merge(m, src)
}
func (m *Support) XXX_Size() int {
	return m.Size()
}
func (m *Support) XXX_DiscardUnknown() {
	xxx_messageInfo_Support.DiscardUnknown(m)
}

var xxx_messageInfo_Support proto.InternalMessageInfo

func (m *Support) GetSupported() bool {
	if m != nil {
		return m.Supported
	}
	return false
}

// Filter
//
// x-displayName: "Filter"
// Filter.
type Filter struct {
	// supported
	//
	// x-displayName: "supported"
	// x-example: "true/false"
	// x-required
	// is filtering supported.
	Supported bool `protobuf:"varint,1,opt,name=supported,proto3" json:"supported,omitempty"`
	// maxResults
	//
	// x-displayName: "schemas"
	// x-example: "5"
	// x-required
	// maximum results to be displayed.
	MaxResults uint64 `protobuf:"varint,2,opt,name=maxResults,proto3" json:"maxResults,omitempty"`
}

func (m *Filter) Reset()      { *m = Filter{} }
func (*Filter) ProtoMessage() {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{2}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetSupported() bool {
	if m != nil {
		return m.Supported
	}
	return false
}

func (m *Filter) GetMaxResults() uint64 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

// ResourceMeta
//
// x-displayName: "ResourceMeta"
// ResourceMeta.
type ResourceMeta struct {
	// resourceType
	//
	// x-displayName: "resourceType"
	// x-example: "User"
	// x-required
	// resourceType represents resource.
	ResourceType string `protobuf:"bytes,1,opt,name=resourceType,proto3" json:"resourceType,omitempty"`
	// location
	//
	// x-displayName: "location"
	// x-example: "/Resurce/User"
	// x-required
	// location of resource.
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *ResourceMeta) Reset()      { *m = ResourceMeta{} }
func (*ResourceMeta) ProtoMessage() {}
func (*ResourceMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{3}
}
func (m *ResourceMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResourceMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMeta.Merge(m, src)
}
func (m *ResourceMeta) XXX_Size() int {
	return m.Size()
}
func (m *ResourceMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMeta proto.InternalMessageInfo

func (m *ResourceMeta) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *ResourceMeta) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// FilterRequest
//
// x-displayName: "FilterRequest"
// FilterRequest.
type FilterRequest struct {
	// filter
	//
	// x-displayName: "filter"
	// x-example: "externalId"
	// Filter to be used for filtering objects.
	Filter string `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	// count
	//
	// x-displayName: "count"
	// x-example: "8"
	// The number of entries after filter.
	Count uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// page
	//
	// x-displayName: "page"
	// x-example: "1"
	// Start offset
	Page uint64 `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *FilterRequest) Reset()      { *m = FilterRequest{} }
func (*FilterRequest) ProtoMessage() {}
func (*FilterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{4}
}
func (m *FilterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FilterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterRequest.Merge(m, src)
}
func (m *FilterRequest) XXX_Size() int {
	return m.Size()
}
func (m *FilterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FilterRequest proto.InternalMessageInfo

func (m *FilterRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *FilterRequest) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FilterRequest) GetPage() uint64 {
	if m != nil {
		return m.Page
	}
	return 0
}

// IdRequest
//
// x-displayName: "IdRequest"
// IdRequest would be incoming request for the user with the given ID.
type IdRequest struct {
	// Id
	//
	// x-displayName: "Email"
	// x-example: "sam.smith@gmail.com"
	// x-required
	// Id with which the request will find entry.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *IdRequest) Reset()      { *m = IdRequest{} }
func (*IdRequest) ProtoMessage() {}
func (*IdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{5}
}
func (m *IdRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdRequest.Merge(m, src)
}
func (m *IdRequest) XXX_Size() int {
	return m.Size()
}
func (m *IdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IdRequest proto.InternalMessageInfo

func (m *IdRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// PatchOperation
//
// x-displayName: "Patch Operation"
// PatchOperation is the patch operation where user can be  updated replaced or remove..
// supported op types are add, remove, replace
// remove is remove a specific entry.
type PatchOperation struct {
	// op
	//
	// x-displayName: "op"
	// x-example: ""op": "add""
	// op "add", "replace", "remove", "delete"
	Op string `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	// path
	//
	// x-displayName: "path"
	// x-example: ""path": "name.formatted""
	// path to the field where the change needs to happen.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// value
	//
	// x-displayName: "value"
	// x-example: ""value": "New Formatted Name""
	// value to be used for modifying the object. In case of delete nothing needs to be specified.
	Value *types.Value `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PatchOperation) Reset()      { *m = PatchOperation{} }
func (*PatchOperation) ProtoMessage() {}
func (*PatchOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a2a7a0a7eef6459, []int{6}
}
func (m *PatchOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatchOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PatchOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatchOperation.Merge(m, src)
}
func (m *PatchOperation) XXX_Size() int {
	return m.Size()
}
func (m *PatchOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_PatchOperation.DiscardUnknown(m)
}

var xxx_messageInfo_PatchOperation proto.InternalMessageInfo

func (m *PatchOperation) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *PatchOperation) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *PatchOperation) GetValue() *types.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*Meta)(nil), "ves.io.schema.scim.Meta")
	golang_proto.RegisterType((*Meta)(nil), "ves.io.schema.scim.Meta")
	proto.RegisterType((*Support)(nil), "ves.io.schema.scim.Support")
	golang_proto.RegisterType((*Support)(nil), "ves.io.schema.scim.Support")
	proto.RegisterType((*Filter)(nil), "ves.io.schema.scim.Filter")
	golang_proto.RegisterType((*Filter)(nil), "ves.io.schema.scim.Filter")
	proto.RegisterType((*ResourceMeta)(nil), "ves.io.schema.scim.ResourceMeta")
	golang_proto.RegisterType((*ResourceMeta)(nil), "ves.io.schema.scim.ResourceMeta")
	proto.RegisterType((*FilterRequest)(nil), "ves.io.schema.scim.FilterRequest")
	golang_proto.RegisterType((*FilterRequest)(nil), "ves.io.schema.scim.FilterRequest")
	proto.RegisterType((*IdRequest)(nil), "ves.io.schema.scim.IdRequest")
	golang_proto.RegisterType((*IdRequest)(nil), "ves.io.schema.scim.IdRequest")
	proto.RegisterType((*PatchOperation)(nil), "ves.io.schema.scim.PatchOperation")
	golang_proto.RegisterType((*PatchOperation)(nil), "ves.io.schema.scim.PatchOperation")
}

func init() { proto.RegisterFile("ves.io/schema/scim/types.proto", fileDescriptor_3a2a7a0a7eef6459) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/scim/types.proto", fileDescriptor_3a2a7a0a7eef6459)
}

var fileDescriptor_3a2a7a0a7eef6459 = []byte{
	// 526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x3f, 0x8f, 0xd3, 0x4e,
	0x10, 0xf5, 0xfa, 0x97, 0xcb, 0xdd, 0xed, 0xef, 0x88, 0xd0, 0x0a, 0x9d, 0x42, 0x38, 0xad, 0x4e,
	0x6e, 0xa0, 0x20, 0xb6, 0x04, 0x1d, 0x25, 0xc5, 0x09, 0x8a, 0xe3, 0x8f, 0x41, 0x14, 0x34, 0xc8,
	0xb1, 0x27, 0xce, 0x82, 0x73, 0xb3, 0xec, 0xae, 0xcd, 0x5d, 0x47, 0x45, 0xcd, 0x27, 0xa0, 0xe6,
	0x3b, 0xd0, 0x50, 0x22, 0xaa, 0x94, 0x29, 0x89, 0xd3, 0x50, 0xde, 0x47, 0x40, 0xde, 0x75, 0x72,
	0x49, 0x83, 0xe8, 0xe6, 0xcd, 0x7b, 0xfb, 0xf6, 0xcd, 0x68, 0x97, 0xf2, 0x0a, 0x74, 0x28, 0x30,
	0xd2, 0xe9, 0x04, 0xa6, 0x49, 0xa4, 0x53, 0x31, 0x8d, 0xcc, 0x85, 0x04, 0x1d, 0x4a, 0x85, 0x06,
	0x19, 0x73, 0x7c, 0xe8, 0xf8, 0xb0, 0xe1, 0x07, 0xc3, 0x5c, 0x98, 0x49, 0x39, 0x0a, 0x53, 0x9c,
	0x46, 0x39, 0xe6, 0x18, 0x59, 0xe9, 0xa8, 0x1c, 0x5b, 0x64, 0x81, 0xad, 0x9c, 0xc5, 0xe0, 0x28,
	0x47, 0xcc, 0x0b, 0xb8, 0x52, 0x69, 0xa3, 0xca, 0xd4, 0xb4, 0xec, 0xcd, 0xed, 0x00, 0x1b, 0x77,
	0x0f, 0x8e, 0xb7, 0xa9, 0x4a, 0xc0, 0x87, 0x37, 0x28, 0x8d, 0xc0, 0xb3, 0x56, 0x11, 0x7c, 0x21,
	0xb4, 0x73, 0x0a, 0x26, 0x61, 0x01, 0x3d, 0x50, 0xa0, 0xb1, 0x54, 0x29, 0xbc, 0xbc, 0x90, 0xd0,
	0x27, 0xc7, 0xe4, 0xce, 0x7e, 0xbc, 0xd5, 0x63, 0x7d, 0xba, 0x9b, 0x2a, 0x48, 0x0c, 0x64, 0x7d,
	0xdf, 0xd2, 0x2b, 0xd8, 0x9c, 0x2e, 0x12, 0x6d, 0x4e, 0x31, 0x13, 0x63, 0x01, 0x59, 0xff, 0x3f,
	0x77, 0x7a, 0xb3, 0xc7, 0x06, 0x74, 0xaf, 0xc0, 0x34, 0x69, 0x6e, 0xef, 0x77, 0x2c, 0xbf, 0xc6,
	0x8d, 0x73, 0x05, 0x4a, 0x37, 0xd4, 0x8e, 0x73, 0x6e, 0x61, 0x70, 0x9b, 0xee, 0xbe, 0x28, 0xa5,
	0x44, 0x65, 0xd8, 0x11, 0xdd, 0xd7, 0xae, 0x84, 0xcc, 0xe6, 0xdb, 0x8b, 0xaf, 0x1a, 0xc1, 0x09,
	0xed, 0x9e, 0x88, 0xc2, 0x80, 0xfa, 0xbb, 0x8e, 0x71, 0x4a, 0xa7, 0xc9, 0x79, 0x0c, 0xba, 0x2c,
	0x8c, 0xb6, 0x73, 0x74, 0xe2, 0x8d, 0x4e, 0xf0, 0x84, 0x1e, 0xc4, 0xed, 0xd0, 0xff, 0xbc, 0x98,
	0xcd, 0xd1, 0xfc, 0xed, 0xd1, 0x82, 0xe7, 0xf4, 0x9a, 0xcb, 0x15, 0xc3, 0xfb, 0x12, 0xb4, 0x61,
	0x87, 0xb4, 0x3b, 0xb6, 0x8d, 0xd6, 0xaa, 0x45, 0xec, 0x06, 0xdd, 0x49, 0xb1, 0x3c, 0x33, 0x6d,
	0x26, 0x07, 0x18, 0xa3, 0x1d, 0x99, 0xe4, 0x60, 0x37, 0xda, 0x89, 0x6d, 0x1d, 0xdc, 0xa2, 0xfb,
	0x8f, 0xb3, 0x95, 0x5d, 0x8f, 0xfa, 0x22, 0x6b, 0xad, 0x7c, 0x91, 0x05, 0x6f, 0x69, 0xef, 0x59,
	0x62, 0xd2, 0xc9, 0x53, 0x09, 0xca, 0x2d, 0xb7, 0x47, 0x7d, 0x94, 0x2b, 0x05, 0x4a, 0x67, 0x69,
	0x26, 0x6d, 0x52, 0x5b, 0xb3, 0xbb, 0x74, 0xa7, 0x4a, 0x8a, 0xd2, 0xdd, 0xf3, 0xff, 0xbd, 0xc3,
	0xd0, 0x3d, 0xb9, 0x70, 0xf5, 0xe4, 0xc2, 0x57, 0x0d, 0x1b, 0x3b, 0xd1, 0x83, 0xee, 0xcf, 0x6f,
	0xc4, 0xbf, 0x4e, 0x1e, 0x7e, 0x22, 0xb3, 0x05, 0xf7, 0xe6, 0x0b, 0xee, 0x5d, 0x2e, 0x38, 0xf9,
	0x58, 0x73, 0xf2, 0xb5, 0xe6, 0xe4, 0x47, 0xcd, 0xc9, 0xac, 0xe6, 0x64, 0x5e, 0x73, 0xf2, 0xab,
	0xe6, 0xe4, 0x77, 0xcd, 0xbd, 0xcb, 0x9a, 0x93, 0xcf, 0x4b, 0xee, 0x7d, 0x5f, 0x72, 0x32, 0x5b,
	0x72, 0x6f, 0xbe, 0xe4, 0xde, 0xeb, 0x47, 0x39, 0xca, 0x77, 0x79, 0x58, 0x61, 0x33, 0xbf, 0x4a,
	0xc2, 0x52, 0x47, 0xb6, 0x18, 0xa3, 0x9a, 0x0e, 0xa5, 0xc2, 0x4a, 0x64, 0xa0, 0x86, 0x2b, 0x3a,
	0x92, 0xa3, 0x1c, 0x23, 0x38, 0x37, 0xeb, 0x9f, 0xb6, 0xfe, 0x70, 0xa3, 0xae, 0xcd, 0x79, 0xff,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4b, 0x7e, 0x46, 0xea, 0x8d, 0x03, 0x00, 0x00,
}

func (this *Meta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Meta)
	if !ok {
		that2, ok := that.(Meta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceType != that1.ResourceType {
		return false
	}
	if this.Created != that1.Created {
		return false
	}
	if this.LastModified != that1.LastModified {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *Support) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Support)
	if !ok {
		that2, ok := that.(Support)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Supported != that1.Supported {
		return false
	}
	return true
}
func (this *Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Filter)
	if !ok {
		that2, ok := that.(Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Supported != that1.Supported {
		return false
	}
	if this.MaxResults != that1.MaxResults {
		return false
	}
	return true
}
func (this *ResourceMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResourceMeta)
	if !ok {
		that2, ok := that.(ResourceMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceType != that1.ResourceType {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	return true
}
func (this *FilterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FilterRequest)
	if !ok {
		that2, ok := that.(FilterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Filter != that1.Filter {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Page != that1.Page {
		return false
	}
	return true
}
func (this *IdRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdRequest)
	if !ok {
		that2, ok := that.(IdRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *PatchOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PatchOperation)
	if !ok {
		that2, ok := that.(PatchOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Meta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&scim.Meta{")
	s = append(s, "ResourceType: "+fmt.Sprintf("%#v", this.ResourceType)+",\n")
	s = append(s, "Created: "+fmt.Sprintf("%#v", this.Created)+",\n")
	s = append(s, "LastModified: "+fmt.Sprintf("%#v", this.LastModified)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Support) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&scim.Support{")
	s = append(s, "Supported: "+fmt.Sprintf("%#v", this.Supported)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&scim.Filter{")
	s = append(s, "Supported: "+fmt.Sprintf("%#v", this.Supported)+",\n")
	s = append(s, "MaxResults: "+fmt.Sprintf("%#v", this.MaxResults)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&scim.ResourceMeta{")
	s = append(s, "ResourceType: "+fmt.Sprintf("%#v", this.ResourceType)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FilterRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&scim.FilterRequest{")
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Page: "+fmt.Sprintf("%#v", this.Page)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IdRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&scim.IdRequest{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PatchOperation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&scim.PatchOperation{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Meta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LastModified) > 0 {
		i -= len(m.LastModified)
		copy(dAtA[i:], m.LastModified)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastModified)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Created) > 0 {
		i -= len(m.Created)
		copy(dAtA[i:], m.Created)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Created)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Support) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Support) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Support) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Supported {
		i--
		if m.Supported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxResults != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxResults))
		i--
		dAtA[i] = 0x10
	}
	if m.Supported {
		i--
		if m.Supported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FilterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FilterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x18
	}
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PatchOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatchOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatchOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Meta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Support) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Supported {
		n += 2
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Supported {
		n += 2
	}
	if m.MaxResults != 0 {
		n += 1 + sovTypes(uint64(m.MaxResults))
	}
	return n
}

func (m *ResourceMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FilterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	if m.Page != 0 {
		n += 1 + sovTypes(uint64(m.Page))
	}
	return n
}

func (m *IdRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PatchOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Meta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Meta{`,
		`ResourceType:` + fmt.Sprintf("%v", this.ResourceType) + `,`,
		`Created:` + fmt.Sprintf("%v", this.Created) + `,`,
		`LastModified:` + fmt.Sprintf("%v", this.LastModified) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Support) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Support{`,
		`Supported:` + fmt.Sprintf("%v", this.Supported) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Filter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Filter{`,
		`Supported:` + fmt.Sprintf("%v", this.Supported) + `,`,
		`MaxResults:` + fmt.Sprintf("%v", this.MaxResults) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceMeta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceMeta{`,
		`ResourceType:` + fmt.Sprintf("%v", this.ResourceType) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FilterRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FilterRequest{`,
		`Filter:` + fmt.Sprintf("%v", this.Filter) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Page:` + fmt.Sprintf("%v", this.Page) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdRequest{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PatchOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PatchOperation{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Value:` + strings.Replace(fmt.Sprintf("%v", this.Value), "Value", "types.Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Meta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Support) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Support: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Support: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Supported = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Supported = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatchOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatchOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatchOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
