//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package log

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CardinalityAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CardinalityAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CardinalityAggregationData) DeepCopy() *CardinalityAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CardinalityAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CardinalityAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CardinalityAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CardinalityAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateCardinalityAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCardinalityAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CardinalityAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CardinalityAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCardinalityAggregationDataValidator = func() *ValidateCardinalityAggregationData {
	v := &ValidateCardinalityAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CardinalityAggregationDataValidator() db.Validator {
	return DefaultCardinalityAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *DateAggregationBucket) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateAggregationBucket) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateAggregationBucket) DeepCopy() *DateAggregationBucket {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateAggregationBucket{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateAggregationBucket) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateAggregationBucket) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateAggregationBucketValidator().Validate(ctx, m, opts...)
}

type ValidateDateAggregationBucket struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateAggregationBucket) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateAggregationBucket)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateAggregationBucket got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		for key, value := range m.GetSubAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["time"]; exists {

		vOpts := append(opts, db.WithValidateField("time"))
		if err := fv(ctx, m.GetTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateAggregationBucketValidator = func() *ValidateDateAggregationBucket {
	v := &ValidateDateAggregationBucket{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateAggregationBucketValidator() db.Validator {
	return DefaultDateAggregationBucketValidator
}

// augmented methods on protoc/std generated struct

func (m *DateAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateAggregationData) DeepCopy() *DateAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateDateAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buckets"]; exists {

		vOpts := append(opts, db.WithValidateField("buckets"))
		for idx, item := range m.GetBuckets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateAggregationDataValidator = func() *ValidateDateAggregationData {
	v := &ValidateDateAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateAggregationDataValidator() db.Validator {
	return DefaultDateAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *DateSubAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateSubAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateSubAggregationData) DeepCopy() *DateSubAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateSubAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateSubAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateSubAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateSubAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateDateSubAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateSubAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateSubAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateSubAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("field_aggregation"))
		if err := fv(ctx, m.GetFieldAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateSubAggregationDataValidator = func() *ValidateDateSubAggregationData {
	v := &ValidateDateSubAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateSubAggregationDataValidator() db.Validator {
	return DefaultDateSubAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldAggregationBucket) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldAggregationBucket) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldAggregationBucket) DeepCopy() *FieldAggregationBucket {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldAggregationBucket{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldAggregationBucket) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldAggregationBucket) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldAggregationBucketValidator().Validate(ctx, m, opts...)
}

type ValidateFieldAggregationBucket struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldAggregationBucket) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldAggregationBucket)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldAggregationBucket got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		for key, value := range m.GetSubAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldAggregationBucketValidator = func() *ValidateFieldAggregationBucket {
	v := &ValidateFieldAggregationBucket{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldAggregationBucketValidator() db.Validator {
	return DefaultFieldAggregationBucketValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldAggregationData) DeepCopy() *FieldAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateFieldAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buckets"]; exists {

		vOpts := append(opts, db.WithValidateField("buckets"))
		for idx, item := range m.GetBuckets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldAggregationDataValidator = func() *ValidateFieldAggregationData {
	v := &ValidateFieldAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldAggregationDataValidator() db.Validator {
	return DefaultFieldAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldSubAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldSubAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldSubAggregationData) DeepCopy() *FieldSubAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldSubAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldSubAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldSubAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldSubAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateFieldSubAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldSubAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldSubAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldSubAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cardinality_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("cardinality_aggregation"))
		if err := fv(ctx, m.GetCardinalityAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldSubAggregationDataValidator = func() *ValidateFieldSubAggregationData {
	v := &ValidateFieldSubAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldSubAggregationDataValidator() db.Validator {
	return DefaultFieldSubAggregationDataValidator
}

// augmented methods on protoc/std generated struct

func (m *LogAggregationData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogAggregationData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogAggregationData) DeepCopy() *LogAggregationData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogAggregationData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogAggregationData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogAggregationData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogAggregationDataValidator().Validate(ctx, m, opts...)
}

type ValidateLogAggregationData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogAggregationData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogAggregationData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogAggregationData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cardinality_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("cardinality_aggregation"))
		if err := fv(ctx, m.GetCardinalityAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["date_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("date_aggregation"))
		if err := fv(ctx, m.GetDateAggregation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["field_aggregation"]; exists {

		vOpts := append(opts, db.WithValidateField("field_aggregation"))
		if err := fv(ctx, m.GetFieldAggregation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogAggregationDataValidator = func() *ValidateLogAggregationData {
	v := &ValidateLogAggregationData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LogAggregationDataValidator() db.Validator {
	return DefaultLogAggregationDataValidator
}
